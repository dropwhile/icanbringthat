// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.22.0
// source: event.sql

package modelx

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const createEvent = `-- name: CreateEvent :one
INSERT INTO event_ (
    user_id, ref_id, name, description,
    item_sort_order, start_time, start_time_tz
)
VALUES (
    $1, $2, $3, $4, $5, $6, $7
)
RETURNING id, ref_id, user_id, name, description, start_time, start_time_tz, created, last_modified, item_sort_order
`

type CreateEventParams struct {
	UserID        int32      `db:"user_id" json:"user_id"`
	RefID         EventRefID `db:"ref_id" json:"ref_id"`
	Name          string     `db:"name" json:"name"`
	Description   string     `db:"description" json:"description"`
	ItemSortOrder []int32    `db:"item_sort_order" json:"item_sort_order"`
	StartTime     time.Time  `db:"start_time" json:"start_time"`
	StartTimeTz   TimeZone   `db:"start_time_tz" json:"start_time_tz"`
}

func (q *Queries) CreateEvent(ctx context.Context, arg CreateEventParams) (*Event, error) {
	row := q.db.QueryRow(ctx, createEvent,
		arg.UserID,
		arg.RefID,
		arg.Name,
		arg.Description,
		arg.ItemSortOrder,
		arg.StartTime,
		arg.StartTimeTz,
	)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.RefID,
		&i.UserID,
		&i.Name,
		&i.Description,
		&i.StartTime,
		&i.StartTimeTz,
		&i.Created,
		&i.LastModified,
		&i.ItemSortOrder,
	)
	return &i, err
}

const deleteEvent = `-- name: DeleteEvent :exec
DELETE FROM event_
WHERE id = $1
`

func (q *Queries) DeleteEvent(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteEvent, id)
	return err
}

const getEventById = `-- name: GetEventById :one
SELECT id, ref_id, user_id, name, description, start_time, start_time_tz, created, last_modified, item_sort_order FROM event_
WHERE id = $1
`

// @sqlc-vet-disable
func (q *Queries) GetEventById(ctx context.Context, id int32) (*Event, error) {
	row := q.db.QueryRow(ctx, getEventById, id)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.RefID,
		&i.UserID,
		&i.Name,
		&i.Description,
		&i.StartTime,
		&i.StartTimeTz,
		&i.Created,
		&i.LastModified,
		&i.ItemSortOrder,
	)
	return &i, err
}

const getEventByRefId = `-- name: GetEventByRefId :one
SELECT id, ref_id, user_id, name, description, start_time, start_time_tz, created, last_modified, item_sort_order FROM event_
WHERE ref_id = $1
`

func (q *Queries) GetEventByRefId(ctx context.Context, refID EventRefID) (*Event, error) {
	row := q.db.QueryRow(ctx, getEventByRefId, refID)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.RefID,
		&i.UserID,
		&i.Name,
		&i.Description,
		&i.StartTime,
		&i.StartTimeTz,
		&i.Created,
		&i.LastModified,
		&i.ItemSortOrder,
	)
	return &i, err
}

const getEventCountByUser = `-- name: GetEventCountByUser :one
SELECT count(*) FROM event_
WHERE user_id = $1
`

func (q *Queries) GetEventCountByUser(ctx context.Context, userID int32) (int64, error) {
	row := q.db.QueryRow(ctx, getEventCountByUser, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getEventsByIds = `-- name: GetEventsByIds :many
SELECT id, ref_id, user_id, name, description, start_time, start_time_tz, created, last_modified, item_sort_order FROM event_
WHERE id = ANY($1::int[])
`

// @sqlc-vet-disable
func (q *Queries) GetEventsByIds(ctx context.Context, ids []int32) ([]*Event, error) {
	rows, err := q.db.Query(ctx, getEventsByIds, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Event{}
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.RefID,
			&i.UserID,
			&i.Name,
			&i.Description,
			&i.StartTime,
			&i.StartTimeTz,
			&i.Created,
			&i.LastModified,
			&i.ItemSortOrder,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventsByUserId = `-- name: GetEventsByUserId :many
SELECT id, ref_id, user_id, name, description, start_time, start_time_tz, created, last_modified, item_sort_order FROM event_ 
WHERE
    event_.user_id = $1
ORDER BY start_time DESC, id DESC
`

func (q *Queries) GetEventsByUserId(ctx context.Context, userID int32) ([]*Event, error) {
	rows, err := q.db.Query(ctx, getEventsByUserId, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Event{}
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.RefID,
			&i.UserID,
			&i.Name,
			&i.Description,
			&i.StartTime,
			&i.StartTimeTz,
			&i.Created,
			&i.LastModified,
			&i.ItemSortOrder,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventsByUserPaginated = `-- name: GetEventsByUserPaginated :many
SELECT id, ref_id, user_id, name, description, start_time, start_time_tz, created, last_modified, item_sort_order
FROM event_
WHERE
    event_.user_id = $1
ORDER BY
    start_time DESC,
    id DESC
LIMIT $2 OFFSET $3
`

type GetEventsByUserPaginatedParams struct {
	UserID int32 `db:"user_id" json:"user_id"`
	Limit  int32 `db:"limit" json:"limit"`
	Offset int32 `db:"offset" json:"offset"`
}

func (q *Queries) GetEventsByUserPaginated(ctx context.Context, arg GetEventsByUserPaginatedParams) ([]*Event, error) {
	rows, err := q.db.Query(ctx, getEventsByUserPaginated, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Event{}
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.RefID,
			&i.UserID,
			&i.Name,
			&i.Description,
			&i.StartTime,
			&i.StartTimeTz,
			&i.Created,
			&i.LastModified,
			&i.ItemSortOrder,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventsComingSoonByUserPaginated = `-- name: GetEventsComingSoonByUserPaginated :many
SELECT id, ref_id, user_id, name, description, start_time, start_time_tz, created, last_modified, item_sort_order
FROM event_
WHERE
    event_.user_id = $1 AND
    start_time > CURRENT_TIMESTAMP(0)
ORDER BY 
    start_time ASC,
    id ASC
LIMIT $2 OFFSET $3
`

type GetEventsComingSoonByUserPaginatedParams struct {
	UserID int32 `db:"user_id" json:"user_id"`
	Limit  int32 `db:"limit" json:"limit"`
	Offset int32 `db:"offset" json:"offset"`
}

func (q *Queries) GetEventsComingSoonByUserPaginated(ctx context.Context, arg GetEventsComingSoonByUserPaginatedParams) ([]*Event, error) {
	rows, err := q.db.Query(ctx, getEventsComingSoonByUserPaginated, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Event{}
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.RefID,
			&i.UserID,
			&i.Name,
			&i.Description,
			&i.StartTime,
			&i.StartTimeTz,
			&i.Created,
			&i.LastModified,
			&i.ItemSortOrder,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateEvent = `-- name: UpdateEvent :exec
UPDATE event_
SET
    name = COALESCE($1, name),
    description = COALESCE($2, description),
    item_sort_order = COALESCE($3, item_sort_order),
    start_time = COALESCE($4, start_time),
    start_time_tz =  COALESCE($5, start_time_tz)
WHERE id = $6
`

type UpdateEventParams struct {
	Name          *string            `db:"name" json:"name"`
	Description   *string            `db:"description" json:"description"`
	ItemSortOrder []int32            `db:"item_sort_order" json:"item_sort_order"`
	StartTime     pgtype.Timestamptz `db:"start_time" json:"start_time"`
	StartTimeTz   TimeZone           `db:"start_time_tz" json:"start_time_tz"`
	ID            int32              `db:"id" json:"id"`
}

func (q *Queries) UpdateEvent(ctx context.Context, arg UpdateEventParams) error {
	_, err := q.db.Exec(ctx, updateEvent,
		arg.Name,
		arg.Description,
		arg.ItemSortOrder,
		arg.StartTime,
		arg.StartTimeTz,
		arg.ID,
	)
	return err
}
