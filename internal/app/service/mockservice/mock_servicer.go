// Code generated by mockery v2.39.1. DO NOT EDIT.

package mockservice

import (
	context "context"

	errs "github.com/dropwhile/icbt/internal/errs"
	mail "github.com/dropwhile/icbt/internal/mail"

	mock "github.com/stretchr/testify/mock"

	model "github.com/dropwhile/icbt/internal/app/model"

	reftag "github.com/dropwhile/refid/v2/reftag"

	resources "github.com/dropwhile/icbt/internal/app/resources"

	service "github.com/dropwhile/icbt/internal/app/service"

	time "time"
)

// MockServicer is an autogenerated mock type for the Servicer type
type MockServicer struct {
	mock.Mock
}

type MockServicer_Expecter struct {
	mock *mock.Mock
}

func (_m *MockServicer) EXPECT() *MockServicer_Expecter {
	return &MockServicer_Expecter{mock: &_m.Mock}
}

// AddEventItem provides a mock function with given fields: ctx, userID, refID, description
func (_m *MockServicer) AddEventItem(ctx context.Context, userID int, refID reftag.IDt2, description string) (*model.EventItem, errs.Error) {
	ret := _m.Called(ctx, userID, refID, description)

	if len(ret) == 0 {
		panic("no return value specified for AddEventItem")
	}

	var r0 *model.EventItem
	var r1 errs.Error
	if rf, ok := ret.Get(0).(func(context.Context, int, reftag.IDt2, string) (*model.EventItem, errs.Error)); ok {
		return rf(ctx, userID, refID, description)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int, reftag.IDt2, string) *model.EventItem); ok {
		r0 = rf(ctx, userID, refID, description)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.EventItem)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int, reftag.IDt2, string) errs.Error); ok {
		r1 = rf(ctx, userID, refID, description)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(errs.Error)
		}
	}

	return r0, r1
}

// MockServicer_AddEventItem_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddEventItem'
type MockServicer_AddEventItem_Call struct {
	*mock.Call
}

// AddEventItem is a helper method to define mock.On call
//   - ctx context.Context
//   - userID int
//   - refID reftag.IDt2
//   - description string
func (_e *MockServicer_Expecter) AddEventItem(ctx interface{}, userID interface{}, refID interface{}, description interface{}) *MockServicer_AddEventItem_Call {
	return &MockServicer_AddEventItem_Call{Call: _e.mock.On("AddEventItem", ctx, userID, refID, description)}
}

func (_c *MockServicer_AddEventItem_Call) Run(run func(ctx context.Context, userID int, refID reftag.IDt2, description string)) *MockServicer_AddEventItem_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int), args[2].(reftag.IDt2), args[3].(string))
	})
	return _c
}

func (_c *MockServicer_AddEventItem_Call) Return(_a0 *model.EventItem, _a1 errs.Error) *MockServicer_AddEventItem_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockServicer_AddEventItem_Call) RunAndReturn(run func(context.Context, int, reftag.IDt2, string) (*model.EventItem, errs.Error)) *MockServicer_AddEventItem_Call {
	_c.Call.Return(run)
	return _c
}

// AddFavorite provides a mock function with given fields: ctx, userID, refID
func (_m *MockServicer) AddFavorite(ctx context.Context, userID int, refID reftag.IDt2) (*model.Event, errs.Error) {
	ret := _m.Called(ctx, userID, refID)

	if len(ret) == 0 {
		panic("no return value specified for AddFavorite")
	}

	var r0 *model.Event
	var r1 errs.Error
	if rf, ok := ret.Get(0).(func(context.Context, int, reftag.IDt2) (*model.Event, errs.Error)); ok {
		return rf(ctx, userID, refID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int, reftag.IDt2) *model.Event); ok {
		r0 = rf(ctx, userID, refID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.Event)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int, reftag.IDt2) errs.Error); ok {
		r1 = rf(ctx, userID, refID)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(errs.Error)
		}
	}

	return r0, r1
}

// MockServicer_AddFavorite_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddFavorite'
type MockServicer_AddFavorite_Call struct {
	*mock.Call
}

// AddFavorite is a helper method to define mock.On call
//   - ctx context.Context
//   - userID int
//   - refID reftag.IDt2
func (_e *MockServicer_Expecter) AddFavorite(ctx interface{}, userID interface{}, refID interface{}) *MockServicer_AddFavorite_Call {
	return &MockServicer_AddFavorite_Call{Call: _e.mock.On("AddFavorite", ctx, userID, refID)}
}

func (_c *MockServicer_AddFavorite_Call) Run(run func(ctx context.Context, userID int, refID reftag.IDt2)) *MockServicer_AddFavorite_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int), args[2].(reftag.IDt2))
	})
	return _c
}

func (_c *MockServicer_AddFavorite_Call) Return(_a0 *model.Event, _a1 errs.Error) *MockServicer_AddFavorite_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockServicer_AddFavorite_Call) RunAndReturn(run func(context.Context, int, reftag.IDt2) (*model.Event, errs.Error)) *MockServicer_AddFavorite_Call {
	_c.Call.Return(run)
	return _c
}

// ArchiveOldEvents provides a mock function with given fields: ctx
func (_m *MockServicer) ArchiveOldEvents(ctx context.Context) error {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ArchiveOldEvents")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context) error); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockServicer_ArchiveOldEvents_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ArchiveOldEvents'
type MockServicer_ArchiveOldEvents_Call struct {
	*mock.Call
}

// ArchiveOldEvents is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockServicer_Expecter) ArchiveOldEvents(ctx interface{}) *MockServicer_ArchiveOldEvents_Call {
	return &MockServicer_ArchiveOldEvents_Call{Call: _e.mock.On("ArchiveOldEvents", ctx)}
}

func (_c *MockServicer_ArchiveOldEvents_Call) Run(run func(ctx context.Context)) *MockServicer_ArchiveOldEvents_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockServicer_ArchiveOldEvents_Call) Return(_a0 error) *MockServicer_ArchiveOldEvents_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockServicer_ArchiveOldEvents_Call) RunAndReturn(run func(context.Context) error) *MockServicer_ArchiveOldEvents_Call {
	_c.Call.Return(run)
	return _c
}

// CreateEvent provides a mock function with given fields: ctx, user, name, description, when, tz
func (_m *MockServicer) CreateEvent(ctx context.Context, user *model.User, name string, description string, when time.Time, tz string) (*model.Event, errs.Error) {
	ret := _m.Called(ctx, user, name, description, when, tz)

	if len(ret) == 0 {
		panic("no return value specified for CreateEvent")
	}

	var r0 *model.Event
	var r1 errs.Error
	if rf, ok := ret.Get(0).(func(context.Context, *model.User, string, string, time.Time, string) (*model.Event, errs.Error)); ok {
		return rf(ctx, user, name, description, when, tz)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *model.User, string, string, time.Time, string) *model.Event); ok {
		r0 = rf(ctx, user, name, description, when, tz)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.Event)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *model.User, string, string, time.Time, string) errs.Error); ok {
		r1 = rf(ctx, user, name, description, when, tz)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(errs.Error)
		}
	}

	return r0, r1
}

// MockServicer_CreateEvent_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateEvent'
type MockServicer_CreateEvent_Call struct {
	*mock.Call
}

// CreateEvent is a helper method to define mock.On call
//   - ctx context.Context
//   - user *model.User
//   - name string
//   - description string
//   - when time.Time
//   - tz string
func (_e *MockServicer_Expecter) CreateEvent(ctx interface{}, user interface{}, name interface{}, description interface{}, when interface{}, tz interface{}) *MockServicer_CreateEvent_Call {
	return &MockServicer_CreateEvent_Call{Call: _e.mock.On("CreateEvent", ctx, user, name, description, when, tz)}
}

func (_c *MockServicer_CreateEvent_Call) Run(run func(ctx context.Context, user *model.User, name string, description string, when time.Time, tz string)) *MockServicer_CreateEvent_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*model.User), args[2].(string), args[3].(string), args[4].(time.Time), args[5].(string))
	})
	return _c
}

func (_c *MockServicer_CreateEvent_Call) Return(_a0 *model.Event, _a1 errs.Error) *MockServicer_CreateEvent_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockServicer_CreateEvent_Call) RunAndReturn(run func(context.Context, *model.User, string, string, time.Time, string) (*model.Event, errs.Error)) *MockServicer_CreateEvent_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteAllNotifications provides a mock function with given fields: ctx, userID
func (_m *MockServicer) DeleteAllNotifications(ctx context.Context, userID int) errs.Error {
	ret := _m.Called(ctx, userID)

	if len(ret) == 0 {
		panic("no return value specified for DeleteAllNotifications")
	}

	var r0 errs.Error
	if rf, ok := ret.Get(0).(func(context.Context, int) errs.Error); ok {
		r0 = rf(ctx, userID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(errs.Error)
		}
	}

	return r0
}

// MockServicer_DeleteAllNotifications_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteAllNotifications'
type MockServicer_DeleteAllNotifications_Call struct {
	*mock.Call
}

// DeleteAllNotifications is a helper method to define mock.On call
//   - ctx context.Context
//   - userID int
func (_e *MockServicer_Expecter) DeleteAllNotifications(ctx interface{}, userID interface{}) *MockServicer_DeleteAllNotifications_Call {
	return &MockServicer_DeleteAllNotifications_Call{Call: _e.mock.On("DeleteAllNotifications", ctx, userID)}
}

func (_c *MockServicer_DeleteAllNotifications_Call) Run(run func(ctx context.Context, userID int)) *MockServicer_DeleteAllNotifications_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int))
	})
	return _c
}

func (_c *MockServicer_DeleteAllNotifications_Call) Return(_a0 errs.Error) *MockServicer_DeleteAllNotifications_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockServicer_DeleteAllNotifications_Call) RunAndReturn(run func(context.Context, int) errs.Error) *MockServicer_DeleteAllNotifications_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteEarmark provides a mock function with given fields: ctx, userID, earmark
func (_m *MockServicer) DeleteEarmark(ctx context.Context, userID int, earmark *model.Earmark) errs.Error {
	ret := _m.Called(ctx, userID, earmark)

	if len(ret) == 0 {
		panic("no return value specified for DeleteEarmark")
	}

	var r0 errs.Error
	if rf, ok := ret.Get(0).(func(context.Context, int, *model.Earmark) errs.Error); ok {
		r0 = rf(ctx, userID, earmark)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(errs.Error)
		}
	}

	return r0
}

// MockServicer_DeleteEarmark_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteEarmark'
type MockServicer_DeleteEarmark_Call struct {
	*mock.Call
}

// DeleteEarmark is a helper method to define mock.On call
//   - ctx context.Context
//   - userID int
//   - earmark *model.Earmark
func (_e *MockServicer_Expecter) DeleteEarmark(ctx interface{}, userID interface{}, earmark interface{}) *MockServicer_DeleteEarmark_Call {
	return &MockServicer_DeleteEarmark_Call{Call: _e.mock.On("DeleteEarmark", ctx, userID, earmark)}
}

func (_c *MockServicer_DeleteEarmark_Call) Run(run func(ctx context.Context, userID int, earmark *model.Earmark)) *MockServicer_DeleteEarmark_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int), args[2].(*model.Earmark))
	})
	return _c
}

func (_c *MockServicer_DeleteEarmark_Call) Return(_a0 errs.Error) *MockServicer_DeleteEarmark_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockServicer_DeleteEarmark_Call) RunAndReturn(run func(context.Context, int, *model.Earmark) errs.Error) *MockServicer_DeleteEarmark_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteEarmarkByRefID provides a mock function with given fields: ctx, userID, refID
func (_m *MockServicer) DeleteEarmarkByRefID(ctx context.Context, userID int, refID model.EarmarkRefID) errs.Error {
	ret := _m.Called(ctx, userID, refID)

	if len(ret) == 0 {
		panic("no return value specified for DeleteEarmarkByRefID")
	}

	var r0 errs.Error
	if rf, ok := ret.Get(0).(func(context.Context, int, model.EarmarkRefID) errs.Error); ok {
		r0 = rf(ctx, userID, refID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(errs.Error)
		}
	}

	return r0
}

// MockServicer_DeleteEarmarkByRefID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteEarmarkByRefID'
type MockServicer_DeleteEarmarkByRefID_Call struct {
	*mock.Call
}

// DeleteEarmarkByRefID is a helper method to define mock.On call
//   - ctx context.Context
//   - userID int
//   - refID model.EarmarkRefID
func (_e *MockServicer_Expecter) DeleteEarmarkByRefID(ctx interface{}, userID interface{}, refID interface{}) *MockServicer_DeleteEarmarkByRefID_Call {
	return &MockServicer_DeleteEarmarkByRefID_Call{Call: _e.mock.On("DeleteEarmarkByRefID", ctx, userID, refID)}
}

func (_c *MockServicer_DeleteEarmarkByRefID_Call) Run(run func(ctx context.Context, userID int, refID model.EarmarkRefID)) *MockServicer_DeleteEarmarkByRefID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int), args[2].(model.EarmarkRefID))
	})
	return _c
}

func (_c *MockServicer_DeleteEarmarkByRefID_Call) Return(_a0 errs.Error) *MockServicer_DeleteEarmarkByRefID_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockServicer_DeleteEarmarkByRefID_Call) RunAndReturn(run func(context.Context, int, model.EarmarkRefID) errs.Error) *MockServicer_DeleteEarmarkByRefID_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteEvent provides a mock function with given fields: ctx, userID, refID
func (_m *MockServicer) DeleteEvent(ctx context.Context, userID int, refID reftag.IDt2) errs.Error {
	ret := _m.Called(ctx, userID, refID)

	if len(ret) == 0 {
		panic("no return value specified for DeleteEvent")
	}

	var r0 errs.Error
	if rf, ok := ret.Get(0).(func(context.Context, int, reftag.IDt2) errs.Error); ok {
		r0 = rf(ctx, userID, refID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(errs.Error)
		}
	}

	return r0
}

// MockServicer_DeleteEvent_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteEvent'
type MockServicer_DeleteEvent_Call struct {
	*mock.Call
}

// DeleteEvent is a helper method to define mock.On call
//   - ctx context.Context
//   - userID int
//   - refID reftag.IDt2
func (_e *MockServicer_Expecter) DeleteEvent(ctx interface{}, userID interface{}, refID interface{}) *MockServicer_DeleteEvent_Call {
	return &MockServicer_DeleteEvent_Call{Call: _e.mock.On("DeleteEvent", ctx, userID, refID)}
}

func (_c *MockServicer_DeleteEvent_Call) Run(run func(ctx context.Context, userID int, refID reftag.IDt2)) *MockServicer_DeleteEvent_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int), args[2].(reftag.IDt2))
	})
	return _c
}

func (_c *MockServicer_DeleteEvent_Call) Return(_a0 errs.Error) *MockServicer_DeleteEvent_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockServicer_DeleteEvent_Call) RunAndReturn(run func(context.Context, int, reftag.IDt2) errs.Error) *MockServicer_DeleteEvent_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteNotification provides a mock function with given fields: ctx, userID, refID
func (_m *MockServicer) DeleteNotification(ctx context.Context, userID int, refID model.NotificationRefID) errs.Error {
	ret := _m.Called(ctx, userID, refID)

	if len(ret) == 0 {
		panic("no return value specified for DeleteNotification")
	}

	var r0 errs.Error
	if rf, ok := ret.Get(0).(func(context.Context, int, model.NotificationRefID) errs.Error); ok {
		r0 = rf(ctx, userID, refID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(errs.Error)
		}
	}

	return r0
}

// MockServicer_DeleteNotification_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteNotification'
type MockServicer_DeleteNotification_Call struct {
	*mock.Call
}

// DeleteNotification is a helper method to define mock.On call
//   - ctx context.Context
//   - userID int
//   - refID model.NotificationRefID
func (_e *MockServicer_Expecter) DeleteNotification(ctx interface{}, userID interface{}, refID interface{}) *MockServicer_DeleteNotification_Call {
	return &MockServicer_DeleteNotification_Call{Call: _e.mock.On("DeleteNotification", ctx, userID, refID)}
}

func (_c *MockServicer_DeleteNotification_Call) Run(run func(ctx context.Context, userID int, refID model.NotificationRefID)) *MockServicer_DeleteNotification_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int), args[2].(model.NotificationRefID))
	})
	return _c
}

func (_c *MockServicer_DeleteNotification_Call) Return(_a0 errs.Error) *MockServicer_DeleteNotification_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockServicer_DeleteNotification_Call) RunAndReturn(run func(context.Context, int, model.NotificationRefID) errs.Error) *MockServicer_DeleteNotification_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteUser provides a mock function with given fields: ctx, userID
func (_m *MockServicer) DeleteUser(ctx context.Context, userID int) errs.Error {
	ret := _m.Called(ctx, userID)

	if len(ret) == 0 {
		panic("no return value specified for DeleteUser")
	}

	var r0 errs.Error
	if rf, ok := ret.Get(0).(func(context.Context, int) errs.Error); ok {
		r0 = rf(ctx, userID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(errs.Error)
		}
	}

	return r0
}

// MockServicer_DeleteUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteUser'
type MockServicer_DeleteUser_Call struct {
	*mock.Call
}

// DeleteUser is a helper method to define mock.On call
//   - ctx context.Context
//   - userID int
func (_e *MockServicer_Expecter) DeleteUser(ctx interface{}, userID interface{}) *MockServicer_DeleteUser_Call {
	return &MockServicer_DeleteUser_Call{Call: _e.mock.On("DeleteUser", ctx, userID)}
}

func (_c *MockServicer_DeleteUser_Call) Run(run func(ctx context.Context, userID int)) *MockServicer_DeleteUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int))
	})
	return _c
}

func (_c *MockServicer_DeleteUser_Call) Return(_a0 errs.Error) *MockServicer_DeleteUser_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockServicer_DeleteUser_Call) RunAndReturn(run func(context.Context, int) errs.Error) *MockServicer_DeleteUser_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteUserCredential provides a mock function with given fields: ctx, credentialID
func (_m *MockServicer) DeleteUserCredential(ctx context.Context, credentialID int) errs.Error {
	ret := _m.Called(ctx, credentialID)

	if len(ret) == 0 {
		panic("no return value specified for DeleteUserCredential")
	}

	var r0 errs.Error
	if rf, ok := ret.Get(0).(func(context.Context, int) errs.Error); ok {
		r0 = rf(ctx, credentialID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(errs.Error)
		}
	}

	return r0
}

// MockServicer_DeleteUserCredential_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteUserCredential'
type MockServicer_DeleteUserCredential_Call struct {
	*mock.Call
}

// DeleteUserCredential is a helper method to define mock.On call
//   - ctx context.Context
//   - credentialID int
func (_e *MockServicer_Expecter) DeleteUserCredential(ctx interface{}, credentialID interface{}) *MockServicer_DeleteUserCredential_Call {
	return &MockServicer_DeleteUserCredential_Call{Call: _e.mock.On("DeleteUserCredential", ctx, credentialID)}
}

func (_c *MockServicer_DeleteUserCredential_Call) Run(run func(ctx context.Context, credentialID int)) *MockServicer_DeleteUserCredential_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int))
	})
	return _c
}

func (_c *MockServicer_DeleteUserCredential_Call) Return(_a0 errs.Error) *MockServicer_DeleteUserCredential_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockServicer_DeleteUserCredential_Call) RunAndReturn(run func(context.Context, int) errs.Error) *MockServicer_DeleteUserCredential_Call {
	_c.Call.Return(run)
	return _c
}

// DisableRemindersWithNotification provides a mock function with given fields: ctx, email, suppressionReason
func (_m *MockServicer) DisableRemindersWithNotification(ctx context.Context, email string, suppressionReason string) errs.Error {
	ret := _m.Called(ctx, email, suppressionReason)

	if len(ret) == 0 {
		panic("no return value specified for DisableRemindersWithNotification")
	}

	var r0 errs.Error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) errs.Error); ok {
		r0 = rf(ctx, email, suppressionReason)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(errs.Error)
		}
	}

	return r0
}

// MockServicer_DisableRemindersWithNotification_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DisableRemindersWithNotification'
type MockServicer_DisableRemindersWithNotification_Call struct {
	*mock.Call
}

// DisableRemindersWithNotification is a helper method to define mock.On call
//   - ctx context.Context
//   - email string
//   - suppressionReason string
func (_e *MockServicer_Expecter) DisableRemindersWithNotification(ctx interface{}, email interface{}, suppressionReason interface{}) *MockServicer_DisableRemindersWithNotification_Call {
	return &MockServicer_DisableRemindersWithNotification_Call{Call: _e.mock.On("DisableRemindersWithNotification", ctx, email, suppressionReason)}
}

func (_c *MockServicer_DisableRemindersWithNotification_Call) Run(run func(ctx context.Context, email string, suppressionReason string)) *MockServicer_DisableRemindersWithNotification_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockServicer_DisableRemindersWithNotification_Call) Return(_a0 errs.Error) *MockServicer_DisableRemindersWithNotification_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockServicer_DisableRemindersWithNotification_Call) RunAndReturn(run func(context.Context, string, string) errs.Error) *MockServicer_DisableRemindersWithNotification_Call {
	_c.Call.Return(run)
	return _c
}

// GetApiKeyByUser provides a mock function with given fields: ctx, userID
func (_m *MockServicer) GetApiKeyByUser(ctx context.Context, userID int) (*model.ApiKey, errs.Error) {
	ret := _m.Called(ctx, userID)

	if len(ret) == 0 {
		panic("no return value specified for GetApiKeyByUser")
	}

	var r0 *model.ApiKey
	var r1 errs.Error
	if rf, ok := ret.Get(0).(func(context.Context, int) (*model.ApiKey, errs.Error)); ok {
		return rf(ctx, userID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int) *model.ApiKey); ok {
		r0 = rf(ctx, userID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.ApiKey)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int) errs.Error); ok {
		r1 = rf(ctx, userID)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(errs.Error)
		}
	}

	return r0, r1
}

// MockServicer_GetApiKeyByUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetApiKeyByUser'
type MockServicer_GetApiKeyByUser_Call struct {
	*mock.Call
}

// GetApiKeyByUser is a helper method to define mock.On call
//   - ctx context.Context
//   - userID int
func (_e *MockServicer_Expecter) GetApiKeyByUser(ctx interface{}, userID interface{}) *MockServicer_GetApiKeyByUser_Call {
	return &MockServicer_GetApiKeyByUser_Call{Call: _e.mock.On("GetApiKeyByUser", ctx, userID)}
}

func (_c *MockServicer_GetApiKeyByUser_Call) Run(run func(ctx context.Context, userID int)) *MockServicer_GetApiKeyByUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int))
	})
	return _c
}

func (_c *MockServicer_GetApiKeyByUser_Call) Return(_a0 *model.ApiKey, _a1 errs.Error) *MockServicer_GetApiKeyByUser_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockServicer_GetApiKeyByUser_Call) RunAndReturn(run func(context.Context, int) (*model.ApiKey, errs.Error)) *MockServicer_GetApiKeyByUser_Call {
	_c.Call.Return(run)
	return _c
}

// GetEarmark provides a mock function with given fields: ctx, refID
func (_m *MockServicer) GetEarmark(ctx context.Context, refID model.EarmarkRefID) (*model.Earmark, errs.Error) {
	ret := _m.Called(ctx, refID)

	if len(ret) == 0 {
		panic("no return value specified for GetEarmark")
	}

	var r0 *model.Earmark
	var r1 errs.Error
	if rf, ok := ret.Get(0).(func(context.Context, model.EarmarkRefID) (*model.Earmark, errs.Error)); ok {
		return rf(ctx, refID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, model.EarmarkRefID) *model.Earmark); ok {
		r0 = rf(ctx, refID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.Earmark)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, model.EarmarkRefID) errs.Error); ok {
		r1 = rf(ctx, refID)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(errs.Error)
		}
	}

	return r0, r1
}

// MockServicer_GetEarmark_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetEarmark'
type MockServicer_GetEarmark_Call struct {
	*mock.Call
}

// GetEarmark is a helper method to define mock.On call
//   - ctx context.Context
//   - refID model.EarmarkRefID
func (_e *MockServicer_Expecter) GetEarmark(ctx interface{}, refID interface{}) *MockServicer_GetEarmark_Call {
	return &MockServicer_GetEarmark_Call{Call: _e.mock.On("GetEarmark", ctx, refID)}
}

func (_c *MockServicer_GetEarmark_Call) Run(run func(ctx context.Context, refID model.EarmarkRefID)) *MockServicer_GetEarmark_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(model.EarmarkRefID))
	})
	return _c
}

func (_c *MockServicer_GetEarmark_Call) Return(_a0 *model.Earmark, _a1 errs.Error) *MockServicer_GetEarmark_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockServicer_GetEarmark_Call) RunAndReturn(run func(context.Context, model.EarmarkRefID) (*model.Earmark, errs.Error)) *MockServicer_GetEarmark_Call {
	_c.Call.Return(run)
	return _c
}

// GetEarmarkByEventItemID provides a mock function with given fields: ctx, eventItemID
func (_m *MockServicer) GetEarmarkByEventItemID(ctx context.Context, eventItemID int) (*model.Earmark, errs.Error) {
	ret := _m.Called(ctx, eventItemID)

	if len(ret) == 0 {
		panic("no return value specified for GetEarmarkByEventItemID")
	}

	var r0 *model.Earmark
	var r1 errs.Error
	if rf, ok := ret.Get(0).(func(context.Context, int) (*model.Earmark, errs.Error)); ok {
		return rf(ctx, eventItemID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int) *model.Earmark); ok {
		r0 = rf(ctx, eventItemID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.Earmark)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int) errs.Error); ok {
		r1 = rf(ctx, eventItemID)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(errs.Error)
		}
	}

	return r0, r1
}

// MockServicer_GetEarmarkByEventItemID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetEarmarkByEventItemID'
type MockServicer_GetEarmarkByEventItemID_Call struct {
	*mock.Call
}

// GetEarmarkByEventItemID is a helper method to define mock.On call
//   - ctx context.Context
//   - eventItemID int
func (_e *MockServicer_Expecter) GetEarmarkByEventItemID(ctx interface{}, eventItemID interface{}) *MockServicer_GetEarmarkByEventItemID_Call {
	return &MockServicer_GetEarmarkByEventItemID_Call{Call: _e.mock.On("GetEarmarkByEventItemID", ctx, eventItemID)}
}

func (_c *MockServicer_GetEarmarkByEventItemID_Call) Run(run func(ctx context.Context, eventItemID int)) *MockServicer_GetEarmarkByEventItemID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int))
	})
	return _c
}

func (_c *MockServicer_GetEarmarkByEventItemID_Call) Return(_a0 *model.Earmark, _a1 errs.Error) *MockServicer_GetEarmarkByEventItemID_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockServicer_GetEarmarkByEventItemID_Call) RunAndReturn(run func(context.Context, int) (*model.Earmark, errs.Error)) *MockServicer_GetEarmarkByEventItemID_Call {
	_c.Call.Return(run)
	return _c
}

// GetEarmarks provides a mock function with given fields: ctx, userID, archived
func (_m *MockServicer) GetEarmarks(ctx context.Context, userID int, archived bool) ([]*model.Earmark, errs.Error) {
	ret := _m.Called(ctx, userID, archived)

	if len(ret) == 0 {
		panic("no return value specified for GetEarmarks")
	}

	var r0 []*model.Earmark
	var r1 errs.Error
	if rf, ok := ret.Get(0).(func(context.Context, int, bool) ([]*model.Earmark, errs.Error)); ok {
		return rf(ctx, userID, archived)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int, bool) []*model.Earmark); ok {
		r0 = rf(ctx, userID, archived)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*model.Earmark)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int, bool) errs.Error); ok {
		r1 = rf(ctx, userID, archived)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(errs.Error)
		}
	}

	return r0, r1
}

// MockServicer_GetEarmarks_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetEarmarks'
type MockServicer_GetEarmarks_Call struct {
	*mock.Call
}

// GetEarmarks is a helper method to define mock.On call
//   - ctx context.Context
//   - userID int
//   - archived bool
func (_e *MockServicer_Expecter) GetEarmarks(ctx interface{}, userID interface{}, archived interface{}) *MockServicer_GetEarmarks_Call {
	return &MockServicer_GetEarmarks_Call{Call: _e.mock.On("GetEarmarks", ctx, userID, archived)}
}

func (_c *MockServicer_GetEarmarks_Call) Run(run func(ctx context.Context, userID int, archived bool)) *MockServicer_GetEarmarks_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int), args[2].(bool))
	})
	return _c
}

func (_c *MockServicer_GetEarmarks_Call) Return(_a0 []*model.Earmark, _a1 errs.Error) *MockServicer_GetEarmarks_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockServicer_GetEarmarks_Call) RunAndReturn(run func(context.Context, int, bool) ([]*model.Earmark, errs.Error)) *MockServicer_GetEarmarks_Call {
	_c.Call.Return(run)
	return _c
}

// GetEarmarksByEventID provides a mock function with given fields: ctx, eventID
func (_m *MockServicer) GetEarmarksByEventID(ctx context.Context, eventID int) ([]*model.Earmark, errs.Error) {
	ret := _m.Called(ctx, eventID)

	if len(ret) == 0 {
		panic("no return value specified for GetEarmarksByEventID")
	}

	var r0 []*model.Earmark
	var r1 errs.Error
	if rf, ok := ret.Get(0).(func(context.Context, int) ([]*model.Earmark, errs.Error)); ok {
		return rf(ctx, eventID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int) []*model.Earmark); ok {
		r0 = rf(ctx, eventID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*model.Earmark)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int) errs.Error); ok {
		r1 = rf(ctx, eventID)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(errs.Error)
		}
	}

	return r0, r1
}

// MockServicer_GetEarmarksByEventID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetEarmarksByEventID'
type MockServicer_GetEarmarksByEventID_Call struct {
	*mock.Call
}

// GetEarmarksByEventID is a helper method to define mock.On call
//   - ctx context.Context
//   - eventID int
func (_e *MockServicer_Expecter) GetEarmarksByEventID(ctx interface{}, eventID interface{}) *MockServicer_GetEarmarksByEventID_Call {
	return &MockServicer_GetEarmarksByEventID_Call{Call: _e.mock.On("GetEarmarksByEventID", ctx, eventID)}
}

func (_c *MockServicer_GetEarmarksByEventID_Call) Run(run func(ctx context.Context, eventID int)) *MockServicer_GetEarmarksByEventID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int))
	})
	return _c
}

func (_c *MockServicer_GetEarmarksByEventID_Call) Return(_a0 []*model.Earmark, _a1 errs.Error) *MockServicer_GetEarmarksByEventID_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockServicer_GetEarmarksByEventID_Call) RunAndReturn(run func(context.Context, int) ([]*model.Earmark, errs.Error)) *MockServicer_GetEarmarksByEventID_Call {
	_c.Call.Return(run)
	return _c
}

// GetEarmarksCount provides a mock function with given fields: ctx, userID
func (_m *MockServicer) GetEarmarksCount(ctx context.Context, userID int) (*model.BifurcatedRowCounts, errs.Error) {
	ret := _m.Called(ctx, userID)

	if len(ret) == 0 {
		panic("no return value specified for GetEarmarksCount")
	}

	var r0 *model.BifurcatedRowCounts
	var r1 errs.Error
	if rf, ok := ret.Get(0).(func(context.Context, int) (*model.BifurcatedRowCounts, errs.Error)); ok {
		return rf(ctx, userID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int) *model.BifurcatedRowCounts); ok {
		r0 = rf(ctx, userID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.BifurcatedRowCounts)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int) errs.Error); ok {
		r1 = rf(ctx, userID)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(errs.Error)
		}
	}

	return r0, r1
}

// MockServicer_GetEarmarksCount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetEarmarksCount'
type MockServicer_GetEarmarksCount_Call struct {
	*mock.Call
}

// GetEarmarksCount is a helper method to define mock.On call
//   - ctx context.Context
//   - userID int
func (_e *MockServicer_Expecter) GetEarmarksCount(ctx interface{}, userID interface{}) *MockServicer_GetEarmarksCount_Call {
	return &MockServicer_GetEarmarksCount_Call{Call: _e.mock.On("GetEarmarksCount", ctx, userID)}
}

func (_c *MockServicer_GetEarmarksCount_Call) Run(run func(ctx context.Context, userID int)) *MockServicer_GetEarmarksCount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int))
	})
	return _c
}

func (_c *MockServicer_GetEarmarksCount_Call) Return(_a0 *model.BifurcatedRowCounts, _a1 errs.Error) *MockServicer_GetEarmarksCount_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockServicer_GetEarmarksCount_Call) RunAndReturn(run func(context.Context, int) (*model.BifurcatedRowCounts, errs.Error)) *MockServicer_GetEarmarksCount_Call {
	_c.Call.Return(run)
	return _c
}

// GetEarmarksPaginated provides a mock function with given fields: ctx, userID, limit, offset, archived
func (_m *MockServicer) GetEarmarksPaginated(ctx context.Context, userID int, limit int, offset int, archived bool) ([]*model.Earmark, *service.Pagination, errs.Error) {
	ret := _m.Called(ctx, userID, limit, offset, archived)

	if len(ret) == 0 {
		panic("no return value specified for GetEarmarksPaginated")
	}

	var r0 []*model.Earmark
	var r1 *service.Pagination
	var r2 errs.Error
	if rf, ok := ret.Get(0).(func(context.Context, int, int, int, bool) ([]*model.Earmark, *service.Pagination, errs.Error)); ok {
		return rf(ctx, userID, limit, offset, archived)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int, int, int, bool) []*model.Earmark); ok {
		r0 = rf(ctx, userID, limit, offset, archived)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*model.Earmark)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int, int, int, bool) *service.Pagination); ok {
		r1 = rf(ctx, userID, limit, offset, archived)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*service.Pagination)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, int, int, int, bool) errs.Error); ok {
		r2 = rf(ctx, userID, limit, offset, archived)
	} else {
		if ret.Get(2) != nil {
			r2 = ret.Get(2).(errs.Error)
		}
	}

	return r0, r1, r2
}

// MockServicer_GetEarmarksPaginated_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetEarmarksPaginated'
type MockServicer_GetEarmarksPaginated_Call struct {
	*mock.Call
}

// GetEarmarksPaginated is a helper method to define mock.On call
//   - ctx context.Context
//   - userID int
//   - limit int
//   - offset int
//   - archived bool
func (_e *MockServicer_Expecter) GetEarmarksPaginated(ctx interface{}, userID interface{}, limit interface{}, offset interface{}, archived interface{}) *MockServicer_GetEarmarksPaginated_Call {
	return &MockServicer_GetEarmarksPaginated_Call{Call: _e.mock.On("GetEarmarksPaginated", ctx, userID, limit, offset, archived)}
}

func (_c *MockServicer_GetEarmarksPaginated_Call) Run(run func(ctx context.Context, userID int, limit int, offset int, archived bool)) *MockServicer_GetEarmarksPaginated_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int), args[2].(int), args[3].(int), args[4].(bool))
	})
	return _c
}

func (_c *MockServicer_GetEarmarksPaginated_Call) Return(_a0 []*model.Earmark, _a1 *service.Pagination, _a2 errs.Error) *MockServicer_GetEarmarksPaginated_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MockServicer_GetEarmarksPaginated_Call) RunAndReturn(run func(context.Context, int, int, int, bool) ([]*model.Earmark, *service.Pagination, errs.Error)) *MockServicer_GetEarmarksPaginated_Call {
	_c.Call.Return(run)
	return _c
}

// GetEvent provides a mock function with given fields: ctx, refID
func (_m *MockServicer) GetEvent(ctx context.Context, refID reftag.IDt2) (*model.Event, errs.Error) {
	ret := _m.Called(ctx, refID)

	if len(ret) == 0 {
		panic("no return value specified for GetEvent")
	}

	var r0 *model.Event
	var r1 errs.Error
	if rf, ok := ret.Get(0).(func(context.Context, reftag.IDt2) (*model.Event, errs.Error)); ok {
		return rf(ctx, refID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, reftag.IDt2) *model.Event); ok {
		r0 = rf(ctx, refID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.Event)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, reftag.IDt2) errs.Error); ok {
		r1 = rf(ctx, refID)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(errs.Error)
		}
	}

	return r0, r1
}

// MockServicer_GetEvent_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetEvent'
type MockServicer_GetEvent_Call struct {
	*mock.Call
}

// GetEvent is a helper method to define mock.On call
//   - ctx context.Context
//   - refID reftag.IDt2
func (_e *MockServicer_Expecter) GetEvent(ctx interface{}, refID interface{}) *MockServicer_GetEvent_Call {
	return &MockServicer_GetEvent_Call{Call: _e.mock.On("GetEvent", ctx, refID)}
}

func (_c *MockServicer_GetEvent_Call) Run(run func(ctx context.Context, refID reftag.IDt2)) *MockServicer_GetEvent_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(reftag.IDt2))
	})
	return _c
}

func (_c *MockServicer_GetEvent_Call) Return(_a0 *model.Event, _a1 errs.Error) *MockServicer_GetEvent_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockServicer_GetEvent_Call) RunAndReturn(run func(context.Context, reftag.IDt2) (*model.Event, errs.Error)) *MockServicer_GetEvent_Call {
	_c.Call.Return(run)
	return _c
}

// GetEventByID provides a mock function with given fields: ctx, ID
func (_m *MockServicer) GetEventByID(ctx context.Context, ID int) (*model.Event, errs.Error) {
	ret := _m.Called(ctx, ID)

	if len(ret) == 0 {
		panic("no return value specified for GetEventByID")
	}

	var r0 *model.Event
	var r1 errs.Error
	if rf, ok := ret.Get(0).(func(context.Context, int) (*model.Event, errs.Error)); ok {
		return rf(ctx, ID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int) *model.Event); ok {
		r0 = rf(ctx, ID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.Event)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int) errs.Error); ok {
		r1 = rf(ctx, ID)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(errs.Error)
		}
	}

	return r0, r1
}

// MockServicer_GetEventByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetEventByID'
type MockServicer_GetEventByID_Call struct {
	*mock.Call
}

// GetEventByID is a helper method to define mock.On call
//   - ctx context.Context
//   - ID int
func (_e *MockServicer_Expecter) GetEventByID(ctx interface{}, ID interface{}) *MockServicer_GetEventByID_Call {
	return &MockServicer_GetEventByID_Call{Call: _e.mock.On("GetEventByID", ctx, ID)}
}

func (_c *MockServicer_GetEventByID_Call) Run(run func(ctx context.Context, ID int)) *MockServicer_GetEventByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int))
	})
	return _c
}

func (_c *MockServicer_GetEventByID_Call) Return(_a0 *model.Event, _a1 errs.Error) *MockServicer_GetEventByID_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockServicer_GetEventByID_Call) RunAndReturn(run func(context.Context, int) (*model.Event, errs.Error)) *MockServicer_GetEventByID_Call {
	_c.Call.Return(run)
	return _c
}

// GetEventItem provides a mock function with given fields: ctx, eventItemRefID
func (_m *MockServicer) GetEventItem(ctx context.Context, eventItemRefID reftag.IDt3) (*model.EventItem, errs.Error) {
	ret := _m.Called(ctx, eventItemRefID)

	if len(ret) == 0 {
		panic("no return value specified for GetEventItem")
	}

	var r0 *model.EventItem
	var r1 errs.Error
	if rf, ok := ret.Get(0).(func(context.Context, reftag.IDt3) (*model.EventItem, errs.Error)); ok {
		return rf(ctx, eventItemRefID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, reftag.IDt3) *model.EventItem); ok {
		r0 = rf(ctx, eventItemRefID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.EventItem)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, reftag.IDt3) errs.Error); ok {
		r1 = rf(ctx, eventItemRefID)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(errs.Error)
		}
	}

	return r0, r1
}

// MockServicer_GetEventItem_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetEventItem'
type MockServicer_GetEventItem_Call struct {
	*mock.Call
}

// GetEventItem is a helper method to define mock.On call
//   - ctx context.Context
//   - eventItemRefID reftag.IDt3
func (_e *MockServicer_Expecter) GetEventItem(ctx interface{}, eventItemRefID interface{}) *MockServicer_GetEventItem_Call {
	return &MockServicer_GetEventItem_Call{Call: _e.mock.On("GetEventItem", ctx, eventItemRefID)}
}

func (_c *MockServicer_GetEventItem_Call) Run(run func(ctx context.Context, eventItemRefID reftag.IDt3)) *MockServicer_GetEventItem_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(reftag.IDt3))
	})
	return _c
}

func (_c *MockServicer_GetEventItem_Call) Return(_a0 *model.EventItem, _a1 errs.Error) *MockServicer_GetEventItem_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockServicer_GetEventItem_Call) RunAndReturn(run func(context.Context, reftag.IDt3) (*model.EventItem, errs.Error)) *MockServicer_GetEventItem_Call {
	_c.Call.Return(run)
	return _c
}

// GetEventItemByID provides a mock function with given fields: ctx, eventItemID
func (_m *MockServicer) GetEventItemByID(ctx context.Context, eventItemID int) (*model.EventItem, errs.Error) {
	ret := _m.Called(ctx, eventItemID)

	if len(ret) == 0 {
		panic("no return value specified for GetEventItemByID")
	}

	var r0 *model.EventItem
	var r1 errs.Error
	if rf, ok := ret.Get(0).(func(context.Context, int) (*model.EventItem, errs.Error)); ok {
		return rf(ctx, eventItemID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int) *model.EventItem); ok {
		r0 = rf(ctx, eventItemID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.EventItem)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int) errs.Error); ok {
		r1 = rf(ctx, eventItemID)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(errs.Error)
		}
	}

	return r0, r1
}

// MockServicer_GetEventItemByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetEventItemByID'
type MockServicer_GetEventItemByID_Call struct {
	*mock.Call
}

// GetEventItemByID is a helper method to define mock.On call
//   - ctx context.Context
//   - eventItemID int
func (_e *MockServicer_Expecter) GetEventItemByID(ctx interface{}, eventItemID interface{}) *MockServicer_GetEventItemByID_Call {
	return &MockServicer_GetEventItemByID_Call{Call: _e.mock.On("GetEventItemByID", ctx, eventItemID)}
}

func (_c *MockServicer_GetEventItemByID_Call) Run(run func(ctx context.Context, eventItemID int)) *MockServicer_GetEventItemByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int))
	})
	return _c
}

func (_c *MockServicer_GetEventItemByID_Call) Return(_a0 *model.EventItem, _a1 errs.Error) *MockServicer_GetEventItemByID_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockServicer_GetEventItemByID_Call) RunAndReturn(run func(context.Context, int) (*model.EventItem, errs.Error)) *MockServicer_GetEventItemByID_Call {
	_c.Call.Return(run)
	return _c
}

// GetEventItemsByEvent provides a mock function with given fields: ctx, refID
func (_m *MockServicer) GetEventItemsByEvent(ctx context.Context, refID reftag.IDt2) ([]*model.EventItem, errs.Error) {
	ret := _m.Called(ctx, refID)

	if len(ret) == 0 {
		panic("no return value specified for GetEventItemsByEvent")
	}

	var r0 []*model.EventItem
	var r1 errs.Error
	if rf, ok := ret.Get(0).(func(context.Context, reftag.IDt2) ([]*model.EventItem, errs.Error)); ok {
		return rf(ctx, refID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, reftag.IDt2) []*model.EventItem); ok {
		r0 = rf(ctx, refID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*model.EventItem)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, reftag.IDt2) errs.Error); ok {
		r1 = rf(ctx, refID)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(errs.Error)
		}
	}

	return r0, r1
}

// MockServicer_GetEventItemsByEvent_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetEventItemsByEvent'
type MockServicer_GetEventItemsByEvent_Call struct {
	*mock.Call
}

// GetEventItemsByEvent is a helper method to define mock.On call
//   - ctx context.Context
//   - refID reftag.IDt2
func (_e *MockServicer_Expecter) GetEventItemsByEvent(ctx interface{}, refID interface{}) *MockServicer_GetEventItemsByEvent_Call {
	return &MockServicer_GetEventItemsByEvent_Call{Call: _e.mock.On("GetEventItemsByEvent", ctx, refID)}
}

func (_c *MockServicer_GetEventItemsByEvent_Call) Run(run func(ctx context.Context, refID reftag.IDt2)) *MockServicer_GetEventItemsByEvent_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(reftag.IDt2))
	})
	return _c
}

func (_c *MockServicer_GetEventItemsByEvent_Call) Return(_a0 []*model.EventItem, _a1 errs.Error) *MockServicer_GetEventItemsByEvent_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockServicer_GetEventItemsByEvent_Call) RunAndReturn(run func(context.Context, reftag.IDt2) ([]*model.EventItem, errs.Error)) *MockServicer_GetEventItemsByEvent_Call {
	_c.Call.Return(run)
	return _c
}

// GetEventItemsByEventID provides a mock function with given fields: ctx, eventID
func (_m *MockServicer) GetEventItemsByEventID(ctx context.Context, eventID int) ([]*model.EventItem, errs.Error) {
	ret := _m.Called(ctx, eventID)

	if len(ret) == 0 {
		panic("no return value specified for GetEventItemsByEventID")
	}

	var r0 []*model.EventItem
	var r1 errs.Error
	if rf, ok := ret.Get(0).(func(context.Context, int) ([]*model.EventItem, errs.Error)); ok {
		return rf(ctx, eventID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int) []*model.EventItem); ok {
		r0 = rf(ctx, eventID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*model.EventItem)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int) errs.Error); ok {
		r1 = rf(ctx, eventID)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(errs.Error)
		}
	}

	return r0, r1
}

// MockServicer_GetEventItemsByEventID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetEventItemsByEventID'
type MockServicer_GetEventItemsByEventID_Call struct {
	*mock.Call
}

// GetEventItemsByEventID is a helper method to define mock.On call
//   - ctx context.Context
//   - eventID int
func (_e *MockServicer_Expecter) GetEventItemsByEventID(ctx interface{}, eventID interface{}) *MockServicer_GetEventItemsByEventID_Call {
	return &MockServicer_GetEventItemsByEventID_Call{Call: _e.mock.On("GetEventItemsByEventID", ctx, eventID)}
}

func (_c *MockServicer_GetEventItemsByEventID_Call) Run(run func(ctx context.Context, eventID int)) *MockServicer_GetEventItemsByEventID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int))
	})
	return _c
}

func (_c *MockServicer_GetEventItemsByEventID_Call) Return(_a0 []*model.EventItem, _a1 errs.Error) *MockServicer_GetEventItemsByEventID_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockServicer_GetEventItemsByEventID_Call) RunAndReturn(run func(context.Context, int) ([]*model.EventItem, errs.Error)) *MockServicer_GetEventItemsByEventID_Call {
	_c.Call.Return(run)
	return _c
}

// GetEventItemsByIDs provides a mock function with given fields: ctx, eventItemIDs
func (_m *MockServicer) GetEventItemsByIDs(ctx context.Context, eventItemIDs []int) ([]*model.EventItem, errs.Error) {
	ret := _m.Called(ctx, eventItemIDs)

	if len(ret) == 0 {
		panic("no return value specified for GetEventItemsByIDs")
	}

	var r0 []*model.EventItem
	var r1 errs.Error
	if rf, ok := ret.Get(0).(func(context.Context, []int) ([]*model.EventItem, errs.Error)); ok {
		return rf(ctx, eventItemIDs)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []int) []*model.EventItem); ok {
		r0 = rf(ctx, eventItemIDs)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*model.EventItem)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, []int) errs.Error); ok {
		r1 = rf(ctx, eventItemIDs)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(errs.Error)
		}
	}

	return r0, r1
}

// MockServicer_GetEventItemsByIDs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetEventItemsByIDs'
type MockServicer_GetEventItemsByIDs_Call struct {
	*mock.Call
}

// GetEventItemsByIDs is a helper method to define mock.On call
//   - ctx context.Context
//   - eventItemIDs []int
func (_e *MockServicer_Expecter) GetEventItemsByIDs(ctx interface{}, eventItemIDs interface{}) *MockServicer_GetEventItemsByIDs_Call {
	return &MockServicer_GetEventItemsByIDs_Call{Call: _e.mock.On("GetEventItemsByIDs", ctx, eventItemIDs)}
}

func (_c *MockServicer_GetEventItemsByIDs_Call) Run(run func(ctx context.Context, eventItemIDs []int)) *MockServicer_GetEventItemsByIDs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]int))
	})
	return _c
}

func (_c *MockServicer_GetEventItemsByIDs_Call) Return(_a0 []*model.EventItem, _a1 errs.Error) *MockServicer_GetEventItemsByIDs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockServicer_GetEventItemsByIDs_Call) RunAndReturn(run func(context.Context, []int) ([]*model.EventItem, errs.Error)) *MockServicer_GetEventItemsByIDs_Call {
	_c.Call.Return(run)
	return _c
}

// GetEventItemsCount provides a mock function with given fields: ctx, eventIDs
func (_m *MockServicer) GetEventItemsCount(ctx context.Context, eventIDs []int) ([]*model.EventItemCount, errs.Error) {
	ret := _m.Called(ctx, eventIDs)

	if len(ret) == 0 {
		panic("no return value specified for GetEventItemsCount")
	}

	var r0 []*model.EventItemCount
	var r1 errs.Error
	if rf, ok := ret.Get(0).(func(context.Context, []int) ([]*model.EventItemCount, errs.Error)); ok {
		return rf(ctx, eventIDs)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []int) []*model.EventItemCount); ok {
		r0 = rf(ctx, eventIDs)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*model.EventItemCount)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, []int) errs.Error); ok {
		r1 = rf(ctx, eventIDs)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(errs.Error)
		}
	}

	return r0, r1
}

// MockServicer_GetEventItemsCount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetEventItemsCount'
type MockServicer_GetEventItemsCount_Call struct {
	*mock.Call
}

// GetEventItemsCount is a helper method to define mock.On call
//   - ctx context.Context
//   - eventIDs []int
func (_e *MockServicer_Expecter) GetEventItemsCount(ctx interface{}, eventIDs interface{}) *MockServicer_GetEventItemsCount_Call {
	return &MockServicer_GetEventItemsCount_Call{Call: _e.mock.On("GetEventItemsCount", ctx, eventIDs)}
}

func (_c *MockServicer_GetEventItemsCount_Call) Run(run func(ctx context.Context, eventIDs []int)) *MockServicer_GetEventItemsCount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]int))
	})
	return _c
}

func (_c *MockServicer_GetEventItemsCount_Call) Return(_a0 []*model.EventItemCount, _a1 errs.Error) *MockServicer_GetEventItemsCount_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockServicer_GetEventItemsCount_Call) RunAndReturn(run func(context.Context, []int) ([]*model.EventItemCount, errs.Error)) *MockServicer_GetEventItemsCount_Call {
	_c.Call.Return(run)
	return _c
}

// GetEvents provides a mock function with given fields: ctx, userID, archived
func (_m *MockServicer) GetEvents(ctx context.Context, userID int, archived bool) ([]*model.Event, errs.Error) {
	ret := _m.Called(ctx, userID, archived)

	if len(ret) == 0 {
		panic("no return value specified for GetEvents")
	}

	var r0 []*model.Event
	var r1 errs.Error
	if rf, ok := ret.Get(0).(func(context.Context, int, bool) ([]*model.Event, errs.Error)); ok {
		return rf(ctx, userID, archived)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int, bool) []*model.Event); ok {
		r0 = rf(ctx, userID, archived)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*model.Event)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int, bool) errs.Error); ok {
		r1 = rf(ctx, userID, archived)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(errs.Error)
		}
	}

	return r0, r1
}

// MockServicer_GetEvents_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetEvents'
type MockServicer_GetEvents_Call struct {
	*mock.Call
}

// GetEvents is a helper method to define mock.On call
//   - ctx context.Context
//   - userID int
//   - archived bool
func (_e *MockServicer_Expecter) GetEvents(ctx interface{}, userID interface{}, archived interface{}) *MockServicer_GetEvents_Call {
	return &MockServicer_GetEvents_Call{Call: _e.mock.On("GetEvents", ctx, userID, archived)}
}

func (_c *MockServicer_GetEvents_Call) Run(run func(ctx context.Context, userID int, archived bool)) *MockServicer_GetEvents_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int), args[2].(bool))
	})
	return _c
}

func (_c *MockServicer_GetEvents_Call) Return(_a0 []*model.Event, _a1 errs.Error) *MockServicer_GetEvents_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockServicer_GetEvents_Call) RunAndReturn(run func(context.Context, int, bool) ([]*model.Event, errs.Error)) *MockServicer_GetEvents_Call {
	_c.Call.Return(run)
	return _c
}

// GetEventsByIDs provides a mock function with given fields: ctx, eventIDs
func (_m *MockServicer) GetEventsByIDs(ctx context.Context, eventIDs []int) ([]*model.Event, errs.Error) {
	ret := _m.Called(ctx, eventIDs)

	if len(ret) == 0 {
		panic("no return value specified for GetEventsByIDs")
	}

	var r0 []*model.Event
	var r1 errs.Error
	if rf, ok := ret.Get(0).(func(context.Context, []int) ([]*model.Event, errs.Error)); ok {
		return rf(ctx, eventIDs)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []int) []*model.Event); ok {
		r0 = rf(ctx, eventIDs)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*model.Event)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, []int) errs.Error); ok {
		r1 = rf(ctx, eventIDs)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(errs.Error)
		}
	}

	return r0, r1
}

// MockServicer_GetEventsByIDs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetEventsByIDs'
type MockServicer_GetEventsByIDs_Call struct {
	*mock.Call
}

// GetEventsByIDs is a helper method to define mock.On call
//   - ctx context.Context
//   - eventIDs []int
func (_e *MockServicer_Expecter) GetEventsByIDs(ctx interface{}, eventIDs interface{}) *MockServicer_GetEventsByIDs_Call {
	return &MockServicer_GetEventsByIDs_Call{Call: _e.mock.On("GetEventsByIDs", ctx, eventIDs)}
}

func (_c *MockServicer_GetEventsByIDs_Call) Run(run func(ctx context.Context, eventIDs []int)) *MockServicer_GetEventsByIDs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]int))
	})
	return _c
}

func (_c *MockServicer_GetEventsByIDs_Call) Return(_a0 []*model.Event, _a1 errs.Error) *MockServicer_GetEventsByIDs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockServicer_GetEventsByIDs_Call) RunAndReturn(run func(context.Context, []int) ([]*model.Event, errs.Error)) *MockServicer_GetEventsByIDs_Call {
	_c.Call.Return(run)
	return _c
}

// GetEventsComingSoonPaginated provides a mock function with given fields: ctx, userID, limit, offset
func (_m *MockServicer) GetEventsComingSoonPaginated(ctx context.Context, userID int, limit int, offset int) ([]*model.Event, *service.Pagination, errs.Error) {
	ret := _m.Called(ctx, userID, limit, offset)

	if len(ret) == 0 {
		panic("no return value specified for GetEventsComingSoonPaginated")
	}

	var r0 []*model.Event
	var r1 *service.Pagination
	var r2 errs.Error
	if rf, ok := ret.Get(0).(func(context.Context, int, int, int) ([]*model.Event, *service.Pagination, errs.Error)); ok {
		return rf(ctx, userID, limit, offset)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int, int, int) []*model.Event); ok {
		r0 = rf(ctx, userID, limit, offset)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*model.Event)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int, int, int) *service.Pagination); ok {
		r1 = rf(ctx, userID, limit, offset)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*service.Pagination)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, int, int, int) errs.Error); ok {
		r2 = rf(ctx, userID, limit, offset)
	} else {
		if ret.Get(2) != nil {
			r2 = ret.Get(2).(errs.Error)
		}
	}

	return r0, r1, r2
}

// MockServicer_GetEventsComingSoonPaginated_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetEventsComingSoonPaginated'
type MockServicer_GetEventsComingSoonPaginated_Call struct {
	*mock.Call
}

// GetEventsComingSoonPaginated is a helper method to define mock.On call
//   - ctx context.Context
//   - userID int
//   - limit int
//   - offset int
func (_e *MockServicer_Expecter) GetEventsComingSoonPaginated(ctx interface{}, userID interface{}, limit interface{}, offset interface{}) *MockServicer_GetEventsComingSoonPaginated_Call {
	return &MockServicer_GetEventsComingSoonPaginated_Call{Call: _e.mock.On("GetEventsComingSoonPaginated", ctx, userID, limit, offset)}
}

func (_c *MockServicer_GetEventsComingSoonPaginated_Call) Run(run func(ctx context.Context, userID int, limit int, offset int)) *MockServicer_GetEventsComingSoonPaginated_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int), args[2].(int), args[3].(int))
	})
	return _c
}

func (_c *MockServicer_GetEventsComingSoonPaginated_Call) Return(_a0 []*model.Event, _a1 *service.Pagination, _a2 errs.Error) *MockServicer_GetEventsComingSoonPaginated_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MockServicer_GetEventsComingSoonPaginated_Call) RunAndReturn(run func(context.Context, int, int, int) ([]*model.Event, *service.Pagination, errs.Error)) *MockServicer_GetEventsComingSoonPaginated_Call {
	_c.Call.Return(run)
	return _c
}

// GetEventsCount provides a mock function with given fields: ctx, userID
func (_m *MockServicer) GetEventsCount(ctx context.Context, userID int) (*model.BifurcatedRowCounts, errs.Error) {
	ret := _m.Called(ctx, userID)

	if len(ret) == 0 {
		panic("no return value specified for GetEventsCount")
	}

	var r0 *model.BifurcatedRowCounts
	var r1 errs.Error
	if rf, ok := ret.Get(0).(func(context.Context, int) (*model.BifurcatedRowCounts, errs.Error)); ok {
		return rf(ctx, userID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int) *model.BifurcatedRowCounts); ok {
		r0 = rf(ctx, userID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.BifurcatedRowCounts)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int) errs.Error); ok {
		r1 = rf(ctx, userID)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(errs.Error)
		}
	}

	return r0, r1
}

// MockServicer_GetEventsCount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetEventsCount'
type MockServicer_GetEventsCount_Call struct {
	*mock.Call
}

// GetEventsCount is a helper method to define mock.On call
//   - ctx context.Context
//   - userID int
func (_e *MockServicer_Expecter) GetEventsCount(ctx interface{}, userID interface{}) *MockServicer_GetEventsCount_Call {
	return &MockServicer_GetEventsCount_Call{Call: _e.mock.On("GetEventsCount", ctx, userID)}
}

func (_c *MockServicer_GetEventsCount_Call) Run(run func(ctx context.Context, userID int)) *MockServicer_GetEventsCount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int))
	})
	return _c
}

func (_c *MockServicer_GetEventsCount_Call) Return(_a0 *model.BifurcatedRowCounts, _a1 errs.Error) *MockServicer_GetEventsCount_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockServicer_GetEventsCount_Call) RunAndReturn(run func(context.Context, int) (*model.BifurcatedRowCounts, errs.Error)) *MockServicer_GetEventsCount_Call {
	_c.Call.Return(run)
	return _c
}

// GetEventsPaginated provides a mock function with given fields: ctx, userID, limit, offset, archived
func (_m *MockServicer) GetEventsPaginated(ctx context.Context, userID int, limit int, offset int, archived bool) ([]*model.Event, *service.Pagination, errs.Error) {
	ret := _m.Called(ctx, userID, limit, offset, archived)

	if len(ret) == 0 {
		panic("no return value specified for GetEventsPaginated")
	}

	var r0 []*model.Event
	var r1 *service.Pagination
	var r2 errs.Error
	if rf, ok := ret.Get(0).(func(context.Context, int, int, int, bool) ([]*model.Event, *service.Pagination, errs.Error)); ok {
		return rf(ctx, userID, limit, offset, archived)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int, int, int, bool) []*model.Event); ok {
		r0 = rf(ctx, userID, limit, offset, archived)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*model.Event)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int, int, int, bool) *service.Pagination); ok {
		r1 = rf(ctx, userID, limit, offset, archived)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*service.Pagination)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, int, int, int, bool) errs.Error); ok {
		r2 = rf(ctx, userID, limit, offset, archived)
	} else {
		if ret.Get(2) != nil {
			r2 = ret.Get(2).(errs.Error)
		}
	}

	return r0, r1, r2
}

// MockServicer_GetEventsPaginated_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetEventsPaginated'
type MockServicer_GetEventsPaginated_Call struct {
	*mock.Call
}

// GetEventsPaginated is a helper method to define mock.On call
//   - ctx context.Context
//   - userID int
//   - limit int
//   - offset int
//   - archived bool
func (_e *MockServicer_Expecter) GetEventsPaginated(ctx interface{}, userID interface{}, limit interface{}, offset interface{}, archived interface{}) *MockServicer_GetEventsPaginated_Call {
	return &MockServicer_GetEventsPaginated_Call{Call: _e.mock.On("GetEventsPaginated", ctx, userID, limit, offset, archived)}
}

func (_c *MockServicer_GetEventsPaginated_Call) Run(run func(ctx context.Context, userID int, limit int, offset int, archived bool)) *MockServicer_GetEventsPaginated_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int), args[2].(int), args[3].(int), args[4].(bool))
	})
	return _c
}

func (_c *MockServicer_GetEventsPaginated_Call) Return(_a0 []*model.Event, _a1 *service.Pagination, _a2 errs.Error) *MockServicer_GetEventsPaginated_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MockServicer_GetEventsPaginated_Call) RunAndReturn(run func(context.Context, int, int, int, bool) ([]*model.Event, *service.Pagination, errs.Error)) *MockServicer_GetEventsPaginated_Call {
	_c.Call.Return(run)
	return _c
}

// GetFavoriteByUserEvent provides a mock function with given fields: ctx, userID, eventID
func (_m *MockServicer) GetFavoriteByUserEvent(ctx context.Context, userID int, eventID int) (*model.Favorite, errs.Error) {
	ret := _m.Called(ctx, userID, eventID)

	if len(ret) == 0 {
		panic("no return value specified for GetFavoriteByUserEvent")
	}

	var r0 *model.Favorite
	var r1 errs.Error
	if rf, ok := ret.Get(0).(func(context.Context, int, int) (*model.Favorite, errs.Error)); ok {
		return rf(ctx, userID, eventID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int, int) *model.Favorite); ok {
		r0 = rf(ctx, userID, eventID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.Favorite)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int, int) errs.Error); ok {
		r1 = rf(ctx, userID, eventID)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(errs.Error)
		}
	}

	return r0, r1
}

// MockServicer_GetFavoriteByUserEvent_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetFavoriteByUserEvent'
type MockServicer_GetFavoriteByUserEvent_Call struct {
	*mock.Call
}

// GetFavoriteByUserEvent is a helper method to define mock.On call
//   - ctx context.Context
//   - userID int
//   - eventID int
func (_e *MockServicer_Expecter) GetFavoriteByUserEvent(ctx interface{}, userID interface{}, eventID interface{}) *MockServicer_GetFavoriteByUserEvent_Call {
	return &MockServicer_GetFavoriteByUserEvent_Call{Call: _e.mock.On("GetFavoriteByUserEvent", ctx, userID, eventID)}
}

func (_c *MockServicer_GetFavoriteByUserEvent_Call) Run(run func(ctx context.Context, userID int, eventID int)) *MockServicer_GetFavoriteByUserEvent_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int), args[2].(int))
	})
	return _c
}

func (_c *MockServicer_GetFavoriteByUserEvent_Call) Return(_a0 *model.Favorite, _a1 errs.Error) *MockServicer_GetFavoriteByUserEvent_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockServicer_GetFavoriteByUserEvent_Call) RunAndReturn(run func(context.Context, int, int) (*model.Favorite, errs.Error)) *MockServicer_GetFavoriteByUserEvent_Call {
	_c.Call.Return(run)
	return _c
}

// GetFavoriteEvents provides a mock function with given fields: ctx, userID, archived
func (_m *MockServicer) GetFavoriteEvents(ctx context.Context, userID int, archived bool) ([]*model.Event, errs.Error) {
	ret := _m.Called(ctx, userID, archived)

	if len(ret) == 0 {
		panic("no return value specified for GetFavoriteEvents")
	}

	var r0 []*model.Event
	var r1 errs.Error
	if rf, ok := ret.Get(0).(func(context.Context, int, bool) ([]*model.Event, errs.Error)); ok {
		return rf(ctx, userID, archived)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int, bool) []*model.Event); ok {
		r0 = rf(ctx, userID, archived)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*model.Event)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int, bool) errs.Error); ok {
		r1 = rf(ctx, userID, archived)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(errs.Error)
		}
	}

	return r0, r1
}

// MockServicer_GetFavoriteEvents_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetFavoriteEvents'
type MockServicer_GetFavoriteEvents_Call struct {
	*mock.Call
}

// GetFavoriteEvents is a helper method to define mock.On call
//   - ctx context.Context
//   - userID int
//   - archived bool
func (_e *MockServicer_Expecter) GetFavoriteEvents(ctx interface{}, userID interface{}, archived interface{}) *MockServicer_GetFavoriteEvents_Call {
	return &MockServicer_GetFavoriteEvents_Call{Call: _e.mock.On("GetFavoriteEvents", ctx, userID, archived)}
}

func (_c *MockServicer_GetFavoriteEvents_Call) Run(run func(ctx context.Context, userID int, archived bool)) *MockServicer_GetFavoriteEvents_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int), args[2].(bool))
	})
	return _c
}

func (_c *MockServicer_GetFavoriteEvents_Call) Return(_a0 []*model.Event, _a1 errs.Error) *MockServicer_GetFavoriteEvents_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockServicer_GetFavoriteEvents_Call) RunAndReturn(run func(context.Context, int, bool) ([]*model.Event, errs.Error)) *MockServicer_GetFavoriteEvents_Call {
	_c.Call.Return(run)
	return _c
}

// GetFavoriteEventsCount provides a mock function with given fields: ctx, userID
func (_m *MockServicer) GetFavoriteEventsCount(ctx context.Context, userID int) (*model.BifurcatedRowCounts, errs.Error) {
	ret := _m.Called(ctx, userID)

	if len(ret) == 0 {
		panic("no return value specified for GetFavoriteEventsCount")
	}

	var r0 *model.BifurcatedRowCounts
	var r1 errs.Error
	if rf, ok := ret.Get(0).(func(context.Context, int) (*model.BifurcatedRowCounts, errs.Error)); ok {
		return rf(ctx, userID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int) *model.BifurcatedRowCounts); ok {
		r0 = rf(ctx, userID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.BifurcatedRowCounts)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int) errs.Error); ok {
		r1 = rf(ctx, userID)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(errs.Error)
		}
	}

	return r0, r1
}

// MockServicer_GetFavoriteEventsCount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetFavoriteEventsCount'
type MockServicer_GetFavoriteEventsCount_Call struct {
	*mock.Call
}

// GetFavoriteEventsCount is a helper method to define mock.On call
//   - ctx context.Context
//   - userID int
func (_e *MockServicer_Expecter) GetFavoriteEventsCount(ctx interface{}, userID interface{}) *MockServicer_GetFavoriteEventsCount_Call {
	return &MockServicer_GetFavoriteEventsCount_Call{Call: _e.mock.On("GetFavoriteEventsCount", ctx, userID)}
}

func (_c *MockServicer_GetFavoriteEventsCount_Call) Run(run func(ctx context.Context, userID int)) *MockServicer_GetFavoriteEventsCount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int))
	})
	return _c
}

func (_c *MockServicer_GetFavoriteEventsCount_Call) Return(_a0 *model.BifurcatedRowCounts, _a1 errs.Error) *MockServicer_GetFavoriteEventsCount_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockServicer_GetFavoriteEventsCount_Call) RunAndReturn(run func(context.Context, int) (*model.BifurcatedRowCounts, errs.Error)) *MockServicer_GetFavoriteEventsCount_Call {
	_c.Call.Return(run)
	return _c
}

// GetFavoriteEventsPaginated provides a mock function with given fields: ctx, userID, limit, offset, archived
func (_m *MockServicer) GetFavoriteEventsPaginated(ctx context.Context, userID int, limit int, offset int, archived bool) ([]*model.Event, *service.Pagination, errs.Error) {
	ret := _m.Called(ctx, userID, limit, offset, archived)

	if len(ret) == 0 {
		panic("no return value specified for GetFavoriteEventsPaginated")
	}

	var r0 []*model.Event
	var r1 *service.Pagination
	var r2 errs.Error
	if rf, ok := ret.Get(0).(func(context.Context, int, int, int, bool) ([]*model.Event, *service.Pagination, errs.Error)); ok {
		return rf(ctx, userID, limit, offset, archived)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int, int, int, bool) []*model.Event); ok {
		r0 = rf(ctx, userID, limit, offset, archived)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*model.Event)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int, int, int, bool) *service.Pagination); ok {
		r1 = rf(ctx, userID, limit, offset, archived)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*service.Pagination)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, int, int, int, bool) errs.Error); ok {
		r2 = rf(ctx, userID, limit, offset, archived)
	} else {
		if ret.Get(2) != nil {
			r2 = ret.Get(2).(errs.Error)
		}
	}

	return r0, r1, r2
}

// MockServicer_GetFavoriteEventsPaginated_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetFavoriteEventsPaginated'
type MockServicer_GetFavoriteEventsPaginated_Call struct {
	*mock.Call
}

// GetFavoriteEventsPaginated is a helper method to define mock.On call
//   - ctx context.Context
//   - userID int
//   - limit int
//   - offset int
//   - archived bool
func (_e *MockServicer_Expecter) GetFavoriteEventsPaginated(ctx interface{}, userID interface{}, limit interface{}, offset interface{}, archived interface{}) *MockServicer_GetFavoriteEventsPaginated_Call {
	return &MockServicer_GetFavoriteEventsPaginated_Call{Call: _e.mock.On("GetFavoriteEventsPaginated", ctx, userID, limit, offset, archived)}
}

func (_c *MockServicer_GetFavoriteEventsPaginated_Call) Run(run func(ctx context.Context, userID int, limit int, offset int, archived bool)) *MockServicer_GetFavoriteEventsPaginated_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int), args[2].(int), args[3].(int), args[4].(bool))
	})
	return _c
}

func (_c *MockServicer_GetFavoriteEventsPaginated_Call) Return(_a0 []*model.Event, _a1 *service.Pagination, _a2 errs.Error) *MockServicer_GetFavoriteEventsPaginated_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MockServicer_GetFavoriteEventsPaginated_Call) RunAndReturn(run func(context.Context, int, int, int, bool) ([]*model.Event, *service.Pagination, errs.Error)) *MockServicer_GetFavoriteEventsPaginated_Call {
	_c.Call.Return(run)
	return _c
}

// GetNotifications provides a mock function with given fields: ctx, userID
func (_m *MockServicer) GetNotifications(ctx context.Context, userID int) ([]*model.Notification, errs.Error) {
	ret := _m.Called(ctx, userID)

	if len(ret) == 0 {
		panic("no return value specified for GetNotifications")
	}

	var r0 []*model.Notification
	var r1 errs.Error
	if rf, ok := ret.Get(0).(func(context.Context, int) ([]*model.Notification, errs.Error)); ok {
		return rf(ctx, userID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int) []*model.Notification); ok {
		r0 = rf(ctx, userID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*model.Notification)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int) errs.Error); ok {
		r1 = rf(ctx, userID)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(errs.Error)
		}
	}

	return r0, r1
}

// MockServicer_GetNotifications_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetNotifications'
type MockServicer_GetNotifications_Call struct {
	*mock.Call
}

// GetNotifications is a helper method to define mock.On call
//   - ctx context.Context
//   - userID int
func (_e *MockServicer_Expecter) GetNotifications(ctx interface{}, userID interface{}) *MockServicer_GetNotifications_Call {
	return &MockServicer_GetNotifications_Call{Call: _e.mock.On("GetNotifications", ctx, userID)}
}

func (_c *MockServicer_GetNotifications_Call) Run(run func(ctx context.Context, userID int)) *MockServicer_GetNotifications_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int))
	})
	return _c
}

func (_c *MockServicer_GetNotifications_Call) Return(_a0 []*model.Notification, _a1 errs.Error) *MockServicer_GetNotifications_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockServicer_GetNotifications_Call) RunAndReturn(run func(context.Context, int) ([]*model.Notification, errs.Error)) *MockServicer_GetNotifications_Call {
	_c.Call.Return(run)
	return _c
}

// GetNotificationsCount provides a mock function with given fields: ctx, userID
func (_m *MockServicer) GetNotificationsCount(ctx context.Context, userID int) (int, errs.Error) {
	ret := _m.Called(ctx, userID)

	if len(ret) == 0 {
		panic("no return value specified for GetNotificationsCount")
	}

	var r0 int
	var r1 errs.Error
	if rf, ok := ret.Get(0).(func(context.Context, int) (int, errs.Error)); ok {
		return rf(ctx, userID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int) int); ok {
		r0 = rf(ctx, userID)
	} else {
		r0 = ret.Get(0).(int)
	}

	if rf, ok := ret.Get(1).(func(context.Context, int) errs.Error); ok {
		r1 = rf(ctx, userID)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(errs.Error)
		}
	}

	return r0, r1
}

// MockServicer_GetNotificationsCount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetNotificationsCount'
type MockServicer_GetNotificationsCount_Call struct {
	*mock.Call
}

// GetNotificationsCount is a helper method to define mock.On call
//   - ctx context.Context
//   - userID int
func (_e *MockServicer_Expecter) GetNotificationsCount(ctx interface{}, userID interface{}) *MockServicer_GetNotificationsCount_Call {
	return &MockServicer_GetNotificationsCount_Call{Call: _e.mock.On("GetNotificationsCount", ctx, userID)}
}

func (_c *MockServicer_GetNotificationsCount_Call) Run(run func(ctx context.Context, userID int)) *MockServicer_GetNotificationsCount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int))
	})
	return _c
}

func (_c *MockServicer_GetNotificationsCount_Call) Return(_a0 int, _a1 errs.Error) *MockServicer_GetNotificationsCount_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockServicer_GetNotificationsCount_Call) RunAndReturn(run func(context.Context, int) (int, errs.Error)) *MockServicer_GetNotificationsCount_Call {
	_c.Call.Return(run)
	return _c
}

// GetNotificationsPaginated provides a mock function with given fields: ctx, userID, limit, offset
func (_m *MockServicer) GetNotificationsPaginated(ctx context.Context, userID int, limit int, offset int) ([]*model.Notification, *service.Pagination, errs.Error) {
	ret := _m.Called(ctx, userID, limit, offset)

	if len(ret) == 0 {
		panic("no return value specified for GetNotificationsPaginated")
	}

	var r0 []*model.Notification
	var r1 *service.Pagination
	var r2 errs.Error
	if rf, ok := ret.Get(0).(func(context.Context, int, int, int) ([]*model.Notification, *service.Pagination, errs.Error)); ok {
		return rf(ctx, userID, limit, offset)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int, int, int) []*model.Notification); ok {
		r0 = rf(ctx, userID, limit, offset)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*model.Notification)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int, int, int) *service.Pagination); ok {
		r1 = rf(ctx, userID, limit, offset)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*service.Pagination)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, int, int, int) errs.Error); ok {
		r2 = rf(ctx, userID, limit, offset)
	} else {
		if ret.Get(2) != nil {
			r2 = ret.Get(2).(errs.Error)
		}
	}

	return r0, r1, r2
}

// MockServicer_GetNotificationsPaginated_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetNotificationsPaginated'
type MockServicer_GetNotificationsPaginated_Call struct {
	*mock.Call
}

// GetNotificationsPaginated is a helper method to define mock.On call
//   - ctx context.Context
//   - userID int
//   - limit int
//   - offset int
func (_e *MockServicer_Expecter) GetNotificationsPaginated(ctx interface{}, userID interface{}, limit interface{}, offset interface{}) *MockServicer_GetNotificationsPaginated_Call {
	return &MockServicer_GetNotificationsPaginated_Call{Call: _e.mock.On("GetNotificationsPaginated", ctx, userID, limit, offset)}
}

func (_c *MockServicer_GetNotificationsPaginated_Call) Run(run func(ctx context.Context, userID int, limit int, offset int)) *MockServicer_GetNotificationsPaginated_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int), args[2].(int), args[3].(int))
	})
	return _c
}

func (_c *MockServicer_GetNotificationsPaginated_Call) Return(_a0 []*model.Notification, _a1 *service.Pagination, _a2 errs.Error) *MockServicer_GetNotificationsPaginated_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MockServicer_GetNotificationsPaginated_Call) RunAndReturn(run func(context.Context, int, int, int) ([]*model.Notification, *service.Pagination, errs.Error)) *MockServicer_GetNotificationsPaginated_Call {
	_c.Call.Return(run)
	return _c
}

// GetUser provides a mock function with given fields: ctx, refID
func (_m *MockServicer) GetUser(ctx context.Context, refID reftag.IDt1) (*model.User, errs.Error) {
	ret := _m.Called(ctx, refID)

	if len(ret) == 0 {
		panic("no return value specified for GetUser")
	}

	var r0 *model.User
	var r1 errs.Error
	if rf, ok := ret.Get(0).(func(context.Context, reftag.IDt1) (*model.User, errs.Error)); ok {
		return rf(ctx, refID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, reftag.IDt1) *model.User); ok {
		r0 = rf(ctx, refID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.User)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, reftag.IDt1) errs.Error); ok {
		r1 = rf(ctx, refID)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(errs.Error)
		}
	}

	return r0, r1
}

// MockServicer_GetUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUser'
type MockServicer_GetUser_Call struct {
	*mock.Call
}

// GetUser is a helper method to define mock.On call
//   - ctx context.Context
//   - refID reftag.IDt1
func (_e *MockServicer_Expecter) GetUser(ctx interface{}, refID interface{}) *MockServicer_GetUser_Call {
	return &MockServicer_GetUser_Call{Call: _e.mock.On("GetUser", ctx, refID)}
}

func (_c *MockServicer_GetUser_Call) Run(run func(ctx context.Context, refID reftag.IDt1)) *MockServicer_GetUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(reftag.IDt1))
	})
	return _c
}

func (_c *MockServicer_GetUser_Call) Return(_a0 *model.User, _a1 errs.Error) *MockServicer_GetUser_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockServicer_GetUser_Call) RunAndReturn(run func(context.Context, reftag.IDt1) (*model.User, errs.Error)) *MockServicer_GetUser_Call {
	_c.Call.Return(run)
	return _c
}

// GetUserByApiKey provides a mock function with given fields: ctx, token
func (_m *MockServicer) GetUserByApiKey(ctx context.Context, token string) (*model.User, errs.Error) {
	ret := _m.Called(ctx, token)

	if len(ret) == 0 {
		panic("no return value specified for GetUserByApiKey")
	}

	var r0 *model.User
	var r1 errs.Error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*model.User, errs.Error)); ok {
		return rf(ctx, token)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *model.User); ok {
		r0 = rf(ctx, token)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.User)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) errs.Error); ok {
		r1 = rf(ctx, token)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(errs.Error)
		}
	}

	return r0, r1
}

// MockServicer_GetUserByApiKey_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUserByApiKey'
type MockServicer_GetUserByApiKey_Call struct {
	*mock.Call
}

// GetUserByApiKey is a helper method to define mock.On call
//   - ctx context.Context
//   - token string
func (_e *MockServicer_Expecter) GetUserByApiKey(ctx interface{}, token interface{}) *MockServicer_GetUserByApiKey_Call {
	return &MockServicer_GetUserByApiKey_Call{Call: _e.mock.On("GetUserByApiKey", ctx, token)}
}

func (_c *MockServicer_GetUserByApiKey_Call) Run(run func(ctx context.Context, token string)) *MockServicer_GetUserByApiKey_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockServicer_GetUserByApiKey_Call) Return(_a0 *model.User, _a1 errs.Error) *MockServicer_GetUserByApiKey_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockServicer_GetUserByApiKey_Call) RunAndReturn(run func(context.Context, string) (*model.User, errs.Error)) *MockServicer_GetUserByApiKey_Call {
	_c.Call.Return(run)
	return _c
}

// GetUserByEmail provides a mock function with given fields: ctx, email
func (_m *MockServicer) GetUserByEmail(ctx context.Context, email string) (*model.User, errs.Error) {
	ret := _m.Called(ctx, email)

	if len(ret) == 0 {
		panic("no return value specified for GetUserByEmail")
	}

	var r0 *model.User
	var r1 errs.Error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*model.User, errs.Error)); ok {
		return rf(ctx, email)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *model.User); ok {
		r0 = rf(ctx, email)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.User)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) errs.Error); ok {
		r1 = rf(ctx, email)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(errs.Error)
		}
	}

	return r0, r1
}

// MockServicer_GetUserByEmail_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUserByEmail'
type MockServicer_GetUserByEmail_Call struct {
	*mock.Call
}

// GetUserByEmail is a helper method to define mock.On call
//   - ctx context.Context
//   - email string
func (_e *MockServicer_Expecter) GetUserByEmail(ctx interface{}, email interface{}) *MockServicer_GetUserByEmail_Call {
	return &MockServicer_GetUserByEmail_Call{Call: _e.mock.On("GetUserByEmail", ctx, email)}
}

func (_c *MockServicer_GetUserByEmail_Call) Run(run func(ctx context.Context, email string)) *MockServicer_GetUserByEmail_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockServicer_GetUserByEmail_Call) Return(_a0 *model.User, _a1 errs.Error) *MockServicer_GetUserByEmail_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockServicer_GetUserByEmail_Call) RunAndReturn(run func(context.Context, string) (*model.User, errs.Error)) *MockServicer_GetUserByEmail_Call {
	_c.Call.Return(run)
	return _c
}

// GetUserByID provides a mock function with given fields: ctx, ID
func (_m *MockServicer) GetUserByID(ctx context.Context, ID int) (*model.User, errs.Error) {
	ret := _m.Called(ctx, ID)

	if len(ret) == 0 {
		panic("no return value specified for GetUserByID")
	}

	var r0 *model.User
	var r1 errs.Error
	if rf, ok := ret.Get(0).(func(context.Context, int) (*model.User, errs.Error)); ok {
		return rf(ctx, ID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int) *model.User); ok {
		r0 = rf(ctx, ID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.User)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int) errs.Error); ok {
		r1 = rf(ctx, ID)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(errs.Error)
		}
	}

	return r0, r1
}

// MockServicer_GetUserByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUserByID'
type MockServicer_GetUserByID_Call struct {
	*mock.Call
}

// GetUserByID is a helper method to define mock.On call
//   - ctx context.Context
//   - ID int
func (_e *MockServicer_Expecter) GetUserByID(ctx interface{}, ID interface{}) *MockServicer_GetUserByID_Call {
	return &MockServicer_GetUserByID_Call{Call: _e.mock.On("GetUserByID", ctx, ID)}
}

func (_c *MockServicer_GetUserByID_Call) Run(run func(ctx context.Context, ID int)) *MockServicer_GetUserByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int))
	})
	return _c
}

func (_c *MockServicer_GetUserByID_Call) Return(_a0 *model.User, _a1 errs.Error) *MockServicer_GetUserByID_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockServicer_GetUserByID_Call) RunAndReturn(run func(context.Context, int) (*model.User, errs.Error)) *MockServicer_GetUserByID_Call {
	_c.Call.Return(run)
	return _c
}

// GetUserCredentialByRefID provides a mock function with given fields: ctx, refID
func (_m *MockServicer) GetUserCredentialByRefID(ctx context.Context, refID reftag.IDt7) (*model.UserCredential, errs.Error) {
	ret := _m.Called(ctx, refID)

	if len(ret) == 0 {
		panic("no return value specified for GetUserCredentialByRefID")
	}

	var r0 *model.UserCredential
	var r1 errs.Error
	if rf, ok := ret.Get(0).(func(context.Context, reftag.IDt7) (*model.UserCredential, errs.Error)); ok {
		return rf(ctx, refID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, reftag.IDt7) *model.UserCredential); ok {
		r0 = rf(ctx, refID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.UserCredential)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, reftag.IDt7) errs.Error); ok {
		r1 = rf(ctx, refID)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(errs.Error)
		}
	}

	return r0, r1
}

// MockServicer_GetUserCredentialByRefID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUserCredentialByRefID'
type MockServicer_GetUserCredentialByRefID_Call struct {
	*mock.Call
}

// GetUserCredentialByRefID is a helper method to define mock.On call
//   - ctx context.Context
//   - refID reftag.IDt7
func (_e *MockServicer_Expecter) GetUserCredentialByRefID(ctx interface{}, refID interface{}) *MockServicer_GetUserCredentialByRefID_Call {
	return &MockServicer_GetUserCredentialByRefID_Call{Call: _e.mock.On("GetUserCredentialByRefID", ctx, refID)}
}

func (_c *MockServicer_GetUserCredentialByRefID_Call) Run(run func(ctx context.Context, refID reftag.IDt7)) *MockServicer_GetUserCredentialByRefID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(reftag.IDt7))
	})
	return _c
}

func (_c *MockServicer_GetUserCredentialByRefID_Call) Return(_a0 *model.UserCredential, _a1 errs.Error) *MockServicer_GetUserCredentialByRefID_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockServicer_GetUserCredentialByRefID_Call) RunAndReturn(run func(context.Context, reftag.IDt7) (*model.UserCredential, errs.Error)) *MockServicer_GetUserCredentialByRefID_Call {
	_c.Call.Return(run)
	return _c
}

// GetUserCredentialCountByUser provides a mock function with given fields: ctx, userID
func (_m *MockServicer) GetUserCredentialCountByUser(ctx context.Context, userID int) (int, errs.Error) {
	ret := _m.Called(ctx, userID)

	if len(ret) == 0 {
		panic("no return value specified for GetUserCredentialCountByUser")
	}

	var r0 int
	var r1 errs.Error
	if rf, ok := ret.Get(0).(func(context.Context, int) (int, errs.Error)); ok {
		return rf(ctx, userID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int) int); ok {
		r0 = rf(ctx, userID)
	} else {
		r0 = ret.Get(0).(int)
	}

	if rf, ok := ret.Get(1).(func(context.Context, int) errs.Error); ok {
		r1 = rf(ctx, userID)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(errs.Error)
		}
	}

	return r0, r1
}

// MockServicer_GetUserCredentialCountByUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUserCredentialCountByUser'
type MockServicer_GetUserCredentialCountByUser_Call struct {
	*mock.Call
}

// GetUserCredentialCountByUser is a helper method to define mock.On call
//   - ctx context.Context
//   - userID int
func (_e *MockServicer_Expecter) GetUserCredentialCountByUser(ctx interface{}, userID interface{}) *MockServicer_GetUserCredentialCountByUser_Call {
	return &MockServicer_GetUserCredentialCountByUser_Call{Call: _e.mock.On("GetUserCredentialCountByUser", ctx, userID)}
}

func (_c *MockServicer_GetUserCredentialCountByUser_Call) Run(run func(ctx context.Context, userID int)) *MockServicer_GetUserCredentialCountByUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int))
	})
	return _c
}

func (_c *MockServicer_GetUserCredentialCountByUser_Call) Return(_a0 int, _a1 errs.Error) *MockServicer_GetUserCredentialCountByUser_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockServicer_GetUserCredentialCountByUser_Call) RunAndReturn(run func(context.Context, int) (int, errs.Error)) *MockServicer_GetUserCredentialCountByUser_Call {
	_c.Call.Return(run)
	return _c
}

// GetUserCredentialsByUser provides a mock function with given fields: ctx, userID
func (_m *MockServicer) GetUserCredentialsByUser(ctx context.Context, userID int) ([]*model.UserCredential, errs.Error) {
	ret := _m.Called(ctx, userID)

	if len(ret) == 0 {
		panic("no return value specified for GetUserCredentialsByUser")
	}

	var r0 []*model.UserCredential
	var r1 errs.Error
	if rf, ok := ret.Get(0).(func(context.Context, int) ([]*model.UserCredential, errs.Error)); ok {
		return rf(ctx, userID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int) []*model.UserCredential); ok {
		r0 = rf(ctx, userID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*model.UserCredential)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int) errs.Error); ok {
		r1 = rf(ctx, userID)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(errs.Error)
		}
	}

	return r0, r1
}

// MockServicer_GetUserCredentialsByUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUserCredentialsByUser'
type MockServicer_GetUserCredentialsByUser_Call struct {
	*mock.Call
}

// GetUserCredentialsByUser is a helper method to define mock.On call
//   - ctx context.Context
//   - userID int
func (_e *MockServicer_Expecter) GetUserCredentialsByUser(ctx interface{}, userID interface{}) *MockServicer_GetUserCredentialsByUser_Call {
	return &MockServicer_GetUserCredentialsByUser_Call{Call: _e.mock.On("GetUserCredentialsByUser", ctx, userID)}
}

func (_c *MockServicer_GetUserCredentialsByUser_Call) Run(run func(ctx context.Context, userID int)) *MockServicer_GetUserCredentialsByUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int))
	})
	return _c
}

func (_c *MockServicer_GetUserCredentialsByUser_Call) Return(_a0 []*model.UserCredential, _a1 errs.Error) *MockServicer_GetUserCredentialsByUser_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockServicer_GetUserCredentialsByUser_Call) RunAndReturn(run func(context.Context, int) ([]*model.UserCredential, errs.Error)) *MockServicer_GetUserCredentialsByUser_Call {
	_c.Call.Return(run)
	return _c
}

// GetUserPWResetByRefID provides a mock function with given fields: ctx, refID
func (_m *MockServicer) GetUserPWResetByRefID(ctx context.Context, refID reftag.IDt5) (*model.UserPWReset, errs.Error) {
	ret := _m.Called(ctx, refID)

	if len(ret) == 0 {
		panic("no return value specified for GetUserPWResetByRefID")
	}

	var r0 *model.UserPWReset
	var r1 errs.Error
	if rf, ok := ret.Get(0).(func(context.Context, reftag.IDt5) (*model.UserPWReset, errs.Error)); ok {
		return rf(ctx, refID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, reftag.IDt5) *model.UserPWReset); ok {
		r0 = rf(ctx, refID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.UserPWReset)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, reftag.IDt5) errs.Error); ok {
		r1 = rf(ctx, refID)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(errs.Error)
		}
	}

	return r0, r1
}

// MockServicer_GetUserPWResetByRefID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUserPWResetByRefID'
type MockServicer_GetUserPWResetByRefID_Call struct {
	*mock.Call
}

// GetUserPWResetByRefID is a helper method to define mock.On call
//   - ctx context.Context
//   - refID reftag.IDt5
func (_e *MockServicer_Expecter) GetUserPWResetByRefID(ctx interface{}, refID interface{}) *MockServicer_GetUserPWResetByRefID_Call {
	return &MockServicer_GetUserPWResetByRefID_Call{Call: _e.mock.On("GetUserPWResetByRefID", ctx, refID)}
}

func (_c *MockServicer_GetUserPWResetByRefID_Call) Run(run func(ctx context.Context, refID reftag.IDt5)) *MockServicer_GetUserPWResetByRefID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(reftag.IDt5))
	})
	return _c
}

func (_c *MockServicer_GetUserPWResetByRefID_Call) Return(_a0 *model.UserPWReset, _a1 errs.Error) *MockServicer_GetUserPWResetByRefID_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockServicer_GetUserPWResetByRefID_Call) RunAndReturn(run func(context.Context, reftag.IDt5) (*model.UserPWReset, errs.Error)) *MockServicer_GetUserPWResetByRefID_Call {
	_c.Call.Return(run)
	return _c
}

// GetUserVerifyByRefID provides a mock function with given fields: ctx, refID
func (_m *MockServicer) GetUserVerifyByRefID(ctx context.Context, refID reftag.IDt6) (*model.UserVerify, errs.Error) {
	ret := _m.Called(ctx, refID)

	if len(ret) == 0 {
		panic("no return value specified for GetUserVerifyByRefID")
	}

	var r0 *model.UserVerify
	var r1 errs.Error
	if rf, ok := ret.Get(0).(func(context.Context, reftag.IDt6) (*model.UserVerify, errs.Error)); ok {
		return rf(ctx, refID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, reftag.IDt6) *model.UserVerify); ok {
		r0 = rf(ctx, refID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.UserVerify)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, reftag.IDt6) errs.Error); ok {
		r1 = rf(ctx, refID)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(errs.Error)
		}
	}

	return r0, r1
}

// MockServicer_GetUserVerifyByRefID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUserVerifyByRefID'
type MockServicer_GetUserVerifyByRefID_Call struct {
	*mock.Call
}

// GetUserVerifyByRefID is a helper method to define mock.On call
//   - ctx context.Context
//   - refID reftag.IDt6
func (_e *MockServicer_Expecter) GetUserVerifyByRefID(ctx interface{}, refID interface{}) *MockServicer_GetUserVerifyByRefID_Call {
	return &MockServicer_GetUserVerifyByRefID_Call{Call: _e.mock.On("GetUserVerifyByRefID", ctx, refID)}
}

func (_c *MockServicer_GetUserVerifyByRefID_Call) Run(run func(ctx context.Context, refID reftag.IDt6)) *MockServicer_GetUserVerifyByRefID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(reftag.IDt6))
	})
	return _c
}

func (_c *MockServicer_GetUserVerifyByRefID_Call) Return(_a0 *model.UserVerify, _a1 errs.Error) *MockServicer_GetUserVerifyByRefID_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockServicer_GetUserVerifyByRefID_Call) RunAndReturn(run func(context.Context, reftag.IDt6) (*model.UserVerify, errs.Error)) *MockServicer_GetUserVerifyByRefID_Call {
	_c.Call.Return(run)
	return _c
}

// GetUsersByIDs provides a mock function with given fields: ctx, userIDs
func (_m *MockServicer) GetUsersByIDs(ctx context.Context, userIDs []int) ([]*model.User, errs.Error) {
	ret := _m.Called(ctx, userIDs)

	if len(ret) == 0 {
		panic("no return value specified for GetUsersByIDs")
	}

	var r0 []*model.User
	var r1 errs.Error
	if rf, ok := ret.Get(0).(func(context.Context, []int) ([]*model.User, errs.Error)); ok {
		return rf(ctx, userIDs)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []int) []*model.User); ok {
		r0 = rf(ctx, userIDs)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*model.User)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, []int) errs.Error); ok {
		r1 = rf(ctx, userIDs)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(errs.Error)
		}
	}

	return r0, r1
}

// MockServicer_GetUsersByIDs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUsersByIDs'
type MockServicer_GetUsersByIDs_Call struct {
	*mock.Call
}

// GetUsersByIDs is a helper method to define mock.On call
//   - ctx context.Context
//   - userIDs []int
func (_e *MockServicer_Expecter) GetUsersByIDs(ctx interface{}, userIDs interface{}) *MockServicer_GetUsersByIDs_Call {
	return &MockServicer_GetUsersByIDs_Call{Call: _e.mock.On("GetUsersByIDs", ctx, userIDs)}
}

func (_c *MockServicer_GetUsersByIDs_Call) Run(run func(ctx context.Context, userIDs []int)) *MockServicer_GetUsersByIDs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]int))
	})
	return _c
}

func (_c *MockServicer_GetUsersByIDs_Call) Return(_a0 []*model.User, _a1 errs.Error) *MockServicer_GetUsersByIDs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockServicer_GetUsersByIDs_Call) RunAndReturn(run func(context.Context, []int) ([]*model.User, errs.Error)) *MockServicer_GetUsersByIDs_Call {
	_c.Call.Return(run)
	return _c
}

// NewApiKey provides a mock function with given fields: ctx, userID
func (_m *MockServicer) NewApiKey(ctx context.Context, userID int) (*model.ApiKey, errs.Error) {
	ret := _m.Called(ctx, userID)

	if len(ret) == 0 {
		panic("no return value specified for NewApiKey")
	}

	var r0 *model.ApiKey
	var r1 errs.Error
	if rf, ok := ret.Get(0).(func(context.Context, int) (*model.ApiKey, errs.Error)); ok {
		return rf(ctx, userID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int) *model.ApiKey); ok {
		r0 = rf(ctx, userID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.ApiKey)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int) errs.Error); ok {
		r1 = rf(ctx, userID)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(errs.Error)
		}
	}

	return r0, r1
}

// MockServicer_NewApiKey_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NewApiKey'
type MockServicer_NewApiKey_Call struct {
	*mock.Call
}

// NewApiKey is a helper method to define mock.On call
//   - ctx context.Context
//   - userID int
func (_e *MockServicer_Expecter) NewApiKey(ctx interface{}, userID interface{}) *MockServicer_NewApiKey_Call {
	return &MockServicer_NewApiKey_Call{Call: _e.mock.On("NewApiKey", ctx, userID)}
}

func (_c *MockServicer_NewApiKey_Call) Run(run func(ctx context.Context, userID int)) *MockServicer_NewApiKey_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int))
	})
	return _c
}

func (_c *MockServicer_NewApiKey_Call) Return(_a0 *model.ApiKey, _a1 errs.Error) *MockServicer_NewApiKey_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockServicer_NewApiKey_Call) RunAndReturn(run func(context.Context, int) (*model.ApiKey, errs.Error)) *MockServicer_NewApiKey_Call {
	_c.Call.Return(run)
	return _c
}

// NewApiKeyIfNotExists provides a mock function with given fields: ctx, userID
func (_m *MockServicer) NewApiKeyIfNotExists(ctx context.Context, userID int) (*model.ApiKey, errs.Error) {
	ret := _m.Called(ctx, userID)

	if len(ret) == 0 {
		panic("no return value specified for NewApiKeyIfNotExists")
	}

	var r0 *model.ApiKey
	var r1 errs.Error
	if rf, ok := ret.Get(0).(func(context.Context, int) (*model.ApiKey, errs.Error)); ok {
		return rf(ctx, userID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int) *model.ApiKey); ok {
		r0 = rf(ctx, userID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.ApiKey)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int) errs.Error); ok {
		r1 = rf(ctx, userID)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(errs.Error)
		}
	}

	return r0, r1
}

// MockServicer_NewApiKeyIfNotExists_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NewApiKeyIfNotExists'
type MockServicer_NewApiKeyIfNotExists_Call struct {
	*mock.Call
}

// NewApiKeyIfNotExists is a helper method to define mock.On call
//   - ctx context.Context
//   - userID int
func (_e *MockServicer_Expecter) NewApiKeyIfNotExists(ctx interface{}, userID interface{}) *MockServicer_NewApiKeyIfNotExists_Call {
	return &MockServicer_NewApiKeyIfNotExists_Call{Call: _e.mock.On("NewApiKeyIfNotExists", ctx, userID)}
}

func (_c *MockServicer_NewApiKeyIfNotExists_Call) Run(run func(ctx context.Context, userID int)) *MockServicer_NewApiKeyIfNotExists_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int))
	})
	return _c
}

func (_c *MockServicer_NewApiKeyIfNotExists_Call) Return(_a0 *model.ApiKey, _a1 errs.Error) *MockServicer_NewApiKeyIfNotExists_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockServicer_NewApiKeyIfNotExists_Call) RunAndReturn(run func(context.Context, int) (*model.ApiKey, errs.Error)) *MockServicer_NewApiKeyIfNotExists_Call {
	_c.Call.Return(run)
	return _c
}

// NewEarmark provides a mock function with given fields: ctx, user, eventItemID, note
func (_m *MockServicer) NewEarmark(ctx context.Context, user *model.User, eventItemID int, note string) (*model.Earmark, errs.Error) {
	ret := _m.Called(ctx, user, eventItemID, note)

	if len(ret) == 0 {
		panic("no return value specified for NewEarmark")
	}

	var r0 *model.Earmark
	var r1 errs.Error
	if rf, ok := ret.Get(0).(func(context.Context, *model.User, int, string) (*model.Earmark, errs.Error)); ok {
		return rf(ctx, user, eventItemID, note)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *model.User, int, string) *model.Earmark); ok {
		r0 = rf(ctx, user, eventItemID, note)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.Earmark)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *model.User, int, string) errs.Error); ok {
		r1 = rf(ctx, user, eventItemID, note)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(errs.Error)
		}
	}

	return r0, r1
}

// MockServicer_NewEarmark_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NewEarmark'
type MockServicer_NewEarmark_Call struct {
	*mock.Call
}

// NewEarmark is a helper method to define mock.On call
//   - ctx context.Context
//   - user *model.User
//   - eventItemID int
//   - note string
func (_e *MockServicer_Expecter) NewEarmark(ctx interface{}, user interface{}, eventItemID interface{}, note interface{}) *MockServicer_NewEarmark_Call {
	return &MockServicer_NewEarmark_Call{Call: _e.mock.On("NewEarmark", ctx, user, eventItemID, note)}
}

func (_c *MockServicer_NewEarmark_Call) Run(run func(ctx context.Context, user *model.User, eventItemID int, note string)) *MockServicer_NewEarmark_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*model.User), args[2].(int), args[3].(string))
	})
	return _c
}

func (_c *MockServicer_NewEarmark_Call) Return(_a0 *model.Earmark, _a1 errs.Error) *MockServicer_NewEarmark_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockServicer_NewEarmark_Call) RunAndReturn(run func(context.Context, *model.User, int, string) (*model.Earmark, errs.Error)) *MockServicer_NewEarmark_Call {
	_c.Call.Return(run)
	return _c
}

// NewNotification provides a mock function with given fields: ctx, userID, message
func (_m *MockServicer) NewNotification(ctx context.Context, userID int, message string) (*model.Notification, errs.Error) {
	ret := _m.Called(ctx, userID, message)

	if len(ret) == 0 {
		panic("no return value specified for NewNotification")
	}

	var r0 *model.Notification
	var r1 errs.Error
	if rf, ok := ret.Get(0).(func(context.Context, int, string) (*model.Notification, errs.Error)); ok {
		return rf(ctx, userID, message)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int, string) *model.Notification); ok {
		r0 = rf(ctx, userID, message)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.Notification)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int, string) errs.Error); ok {
		r1 = rf(ctx, userID, message)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(errs.Error)
		}
	}

	return r0, r1
}

// MockServicer_NewNotification_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NewNotification'
type MockServicer_NewNotification_Call struct {
	*mock.Call
}

// NewNotification is a helper method to define mock.On call
//   - ctx context.Context
//   - userID int
//   - message string
func (_e *MockServicer_Expecter) NewNotification(ctx interface{}, userID interface{}, message interface{}) *MockServicer_NewNotification_Call {
	return &MockServicer_NewNotification_Call{Call: _e.mock.On("NewNotification", ctx, userID, message)}
}

func (_c *MockServicer_NewNotification_Call) Run(run func(ctx context.Context, userID int, message string)) *MockServicer_NewNotification_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int), args[2].(string))
	})
	return _c
}

func (_c *MockServicer_NewNotification_Call) Return(_a0 *model.Notification, _a1 errs.Error) *MockServicer_NewNotification_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockServicer_NewNotification_Call) RunAndReturn(run func(context.Context, int, string) (*model.Notification, errs.Error)) *MockServicer_NewNotification_Call {
	_c.Call.Return(run)
	return _c
}

// NewUser provides a mock function with given fields: ctx, email, name, rawPass
func (_m *MockServicer) NewUser(ctx context.Context, email string, name string, rawPass []byte) (*model.User, errs.Error) {
	ret := _m.Called(ctx, email, name, rawPass)

	if len(ret) == 0 {
		panic("no return value specified for NewUser")
	}

	var r0 *model.User
	var r1 errs.Error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, []byte) (*model.User, errs.Error)); ok {
		return rf(ctx, email, name, rawPass)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, []byte) *model.User); ok {
		r0 = rf(ctx, email, name, rawPass)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.User)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, []byte) errs.Error); ok {
		r1 = rf(ctx, email, name, rawPass)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(errs.Error)
		}
	}

	return r0, r1
}

// MockServicer_NewUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NewUser'
type MockServicer_NewUser_Call struct {
	*mock.Call
}

// NewUser is a helper method to define mock.On call
//   - ctx context.Context
//   - email string
//   - name string
//   - rawPass []byte
func (_e *MockServicer_Expecter) NewUser(ctx interface{}, email interface{}, name interface{}, rawPass interface{}) *MockServicer_NewUser_Call {
	return &MockServicer_NewUser_Call{Call: _e.mock.On("NewUser", ctx, email, name, rawPass)}
}

func (_c *MockServicer_NewUser_Call) Run(run func(ctx context.Context, email string, name string, rawPass []byte)) *MockServicer_NewUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].([]byte))
	})
	return _c
}

func (_c *MockServicer_NewUser_Call) Return(_a0 *model.User, _a1 errs.Error) *MockServicer_NewUser_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockServicer_NewUser_Call) RunAndReturn(run func(context.Context, string, string, []byte) (*model.User, errs.Error)) *MockServicer_NewUser_Call {
	_c.Call.Return(run)
	return _c
}

// NewUserCredential provides a mock function with given fields: ctx, userID, keyName, credential
func (_m *MockServicer) NewUserCredential(ctx context.Context, userID int, keyName string, credential []byte) (*model.UserCredential, errs.Error) {
	ret := _m.Called(ctx, userID, keyName, credential)

	if len(ret) == 0 {
		panic("no return value specified for NewUserCredential")
	}

	var r0 *model.UserCredential
	var r1 errs.Error
	if rf, ok := ret.Get(0).(func(context.Context, int, string, []byte) (*model.UserCredential, errs.Error)); ok {
		return rf(ctx, userID, keyName, credential)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int, string, []byte) *model.UserCredential); ok {
		r0 = rf(ctx, userID, keyName, credential)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.UserCredential)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int, string, []byte) errs.Error); ok {
		r1 = rf(ctx, userID, keyName, credential)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(errs.Error)
		}
	}

	return r0, r1
}

// MockServicer_NewUserCredential_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NewUserCredential'
type MockServicer_NewUserCredential_Call struct {
	*mock.Call
}

// NewUserCredential is a helper method to define mock.On call
//   - ctx context.Context
//   - userID int
//   - keyName string
//   - credential []byte
func (_e *MockServicer_Expecter) NewUserCredential(ctx interface{}, userID interface{}, keyName interface{}, credential interface{}) *MockServicer_NewUserCredential_Call {
	return &MockServicer_NewUserCredential_Call{Call: _e.mock.On("NewUserCredential", ctx, userID, keyName, credential)}
}

func (_c *MockServicer_NewUserCredential_Call) Run(run func(ctx context.Context, userID int, keyName string, credential []byte)) *MockServicer_NewUserCredential_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int), args[2].(string), args[3].([]byte))
	})
	return _c
}

func (_c *MockServicer_NewUserCredential_Call) Return(_a0 *model.UserCredential, _a1 errs.Error) *MockServicer_NewUserCredential_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockServicer_NewUserCredential_Call) RunAndReturn(run func(context.Context, int, string, []byte) (*model.UserCredential, errs.Error)) *MockServicer_NewUserCredential_Call {
	_c.Call.Return(run)
	return _c
}

// NewUserPWReset provides a mock function with given fields: ctx, userID
func (_m *MockServicer) NewUserPWReset(ctx context.Context, userID int) (*model.UserPWReset, errs.Error) {
	ret := _m.Called(ctx, userID)

	if len(ret) == 0 {
		panic("no return value specified for NewUserPWReset")
	}

	var r0 *model.UserPWReset
	var r1 errs.Error
	if rf, ok := ret.Get(0).(func(context.Context, int) (*model.UserPWReset, errs.Error)); ok {
		return rf(ctx, userID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int) *model.UserPWReset); ok {
		r0 = rf(ctx, userID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.UserPWReset)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int) errs.Error); ok {
		r1 = rf(ctx, userID)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(errs.Error)
		}
	}

	return r0, r1
}

// MockServicer_NewUserPWReset_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NewUserPWReset'
type MockServicer_NewUserPWReset_Call struct {
	*mock.Call
}

// NewUserPWReset is a helper method to define mock.On call
//   - ctx context.Context
//   - userID int
func (_e *MockServicer_Expecter) NewUserPWReset(ctx interface{}, userID interface{}) *MockServicer_NewUserPWReset_Call {
	return &MockServicer_NewUserPWReset_Call{Call: _e.mock.On("NewUserPWReset", ctx, userID)}
}

func (_c *MockServicer_NewUserPWReset_Call) Run(run func(ctx context.Context, userID int)) *MockServicer_NewUserPWReset_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int))
	})
	return _c
}

func (_c *MockServicer_NewUserPWReset_Call) Return(_a0 *model.UserPWReset, _a1 errs.Error) *MockServicer_NewUserPWReset_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockServicer_NewUserPWReset_Call) RunAndReturn(run func(context.Context, int) (*model.UserPWReset, errs.Error)) *MockServicer_NewUserPWReset_Call {
	_c.Call.Return(run)
	return _c
}

// NewUserVerify provides a mock function with given fields: ctx, userID
func (_m *MockServicer) NewUserVerify(ctx context.Context, userID int) (*model.UserVerify, errs.Error) {
	ret := _m.Called(ctx, userID)

	if len(ret) == 0 {
		panic("no return value specified for NewUserVerify")
	}

	var r0 *model.UserVerify
	var r1 errs.Error
	if rf, ok := ret.Get(0).(func(context.Context, int) (*model.UserVerify, errs.Error)); ok {
		return rf(ctx, userID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int) *model.UserVerify); ok {
		r0 = rf(ctx, userID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.UserVerify)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int) errs.Error); ok {
		r1 = rf(ctx, userID)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(errs.Error)
		}
	}

	return r0, r1
}

// MockServicer_NewUserVerify_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NewUserVerify'
type MockServicer_NewUserVerify_Call struct {
	*mock.Call
}

// NewUserVerify is a helper method to define mock.On call
//   - ctx context.Context
//   - userID int
func (_e *MockServicer_Expecter) NewUserVerify(ctx interface{}, userID interface{}) *MockServicer_NewUserVerify_Call {
	return &MockServicer_NewUserVerify_Call{Call: _e.mock.On("NewUserVerify", ctx, userID)}
}

func (_c *MockServicer_NewUserVerify_Call) Run(run func(ctx context.Context, userID int)) *MockServicer_NewUserVerify_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int))
	})
	return _c
}

func (_c *MockServicer_NewUserVerify_Call) Return(_a0 *model.UserVerify, _a1 errs.Error) *MockServicer_NewUserVerify_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockServicer_NewUserVerify_Call) RunAndReturn(run func(context.Context, int) (*model.UserVerify, errs.Error)) *MockServicer_NewUserVerify_Call {
	_c.Call.Return(run)
	return _c
}

// NotifyUsersPendingEvents provides a mock function with given fields: ctx, mailer, tplContainer, siteBaseUrl
func (_m *MockServicer) NotifyUsersPendingEvents(ctx context.Context, mailer mail.MailSender, tplContainer resources.TGetter, siteBaseUrl string) error {
	ret := _m.Called(ctx, mailer, tplContainer, siteBaseUrl)

	if len(ret) == 0 {
		panic("no return value specified for NotifyUsersPendingEvents")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, mail.MailSender, resources.TGetter, string) error); ok {
		r0 = rf(ctx, mailer, tplContainer, siteBaseUrl)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockServicer_NotifyUsersPendingEvents_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NotifyUsersPendingEvents'
type MockServicer_NotifyUsersPendingEvents_Call struct {
	*mock.Call
}

// NotifyUsersPendingEvents is a helper method to define mock.On call
//   - ctx context.Context
//   - mailer mail.MailSender
//   - tplContainer resources.TGetter
//   - siteBaseUrl string
func (_e *MockServicer_Expecter) NotifyUsersPendingEvents(ctx interface{}, mailer interface{}, tplContainer interface{}, siteBaseUrl interface{}) *MockServicer_NotifyUsersPendingEvents_Call {
	return &MockServicer_NotifyUsersPendingEvents_Call{Call: _e.mock.On("NotifyUsersPendingEvents", ctx, mailer, tplContainer, siteBaseUrl)}
}

func (_c *MockServicer_NotifyUsersPendingEvents_Call) Run(run func(ctx context.Context, mailer mail.MailSender, tplContainer resources.TGetter, siteBaseUrl string)) *MockServicer_NotifyUsersPendingEvents_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(mail.MailSender), args[2].(resources.TGetter), args[3].(string))
	})
	return _c
}

func (_c *MockServicer_NotifyUsersPendingEvents_Call) Return(_a0 error) *MockServicer_NotifyUsersPendingEvents_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockServicer_NotifyUsersPendingEvents_Call) RunAndReturn(run func(context.Context, mail.MailSender, resources.TGetter, string) error) *MockServicer_NotifyUsersPendingEvents_Call {
	_c.Call.Return(run)
	return _c
}

// RemoveEventItem provides a mock function with given fields: ctx, userID, eventItemRefID, failIfChecks
func (_m *MockServicer) RemoveEventItem(ctx context.Context, userID int, eventItemRefID reftag.IDt3, failIfChecks func(*model.EventItem) bool) errs.Error {
	ret := _m.Called(ctx, userID, eventItemRefID, failIfChecks)

	if len(ret) == 0 {
		panic("no return value specified for RemoveEventItem")
	}

	var r0 errs.Error
	if rf, ok := ret.Get(0).(func(context.Context, int, reftag.IDt3, func(*model.EventItem) bool) errs.Error); ok {
		r0 = rf(ctx, userID, eventItemRefID, failIfChecks)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(errs.Error)
		}
	}

	return r0
}

// MockServicer_RemoveEventItem_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoveEventItem'
type MockServicer_RemoveEventItem_Call struct {
	*mock.Call
}

// RemoveEventItem is a helper method to define mock.On call
//   - ctx context.Context
//   - userID int
//   - eventItemRefID reftag.IDt3
//   - failIfChecks func(*model.EventItem) bool
func (_e *MockServicer_Expecter) RemoveEventItem(ctx interface{}, userID interface{}, eventItemRefID interface{}, failIfChecks interface{}) *MockServicer_RemoveEventItem_Call {
	return &MockServicer_RemoveEventItem_Call{Call: _e.mock.On("RemoveEventItem", ctx, userID, eventItemRefID, failIfChecks)}
}

func (_c *MockServicer_RemoveEventItem_Call) Run(run func(ctx context.Context, userID int, eventItemRefID reftag.IDt3, failIfChecks func(*model.EventItem) bool)) *MockServicer_RemoveEventItem_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int), args[2].(reftag.IDt3), args[3].(func(*model.EventItem) bool))
	})
	return _c
}

func (_c *MockServicer_RemoveEventItem_Call) Return(_a0 errs.Error) *MockServicer_RemoveEventItem_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockServicer_RemoveEventItem_Call) RunAndReturn(run func(context.Context, int, reftag.IDt3, func(*model.EventItem) bool) errs.Error) *MockServicer_RemoveEventItem_Call {
	_c.Call.Return(run)
	return _c
}

// RemoveFavorite provides a mock function with given fields: ctx, userID, refID
func (_m *MockServicer) RemoveFavorite(ctx context.Context, userID int, refID reftag.IDt2) errs.Error {
	ret := _m.Called(ctx, userID, refID)

	if len(ret) == 0 {
		panic("no return value specified for RemoveFavorite")
	}

	var r0 errs.Error
	if rf, ok := ret.Get(0).(func(context.Context, int, reftag.IDt2) errs.Error); ok {
		r0 = rf(ctx, userID, refID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(errs.Error)
		}
	}

	return r0
}

// MockServicer_RemoveFavorite_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoveFavorite'
type MockServicer_RemoveFavorite_Call struct {
	*mock.Call
}

// RemoveFavorite is a helper method to define mock.On call
//   - ctx context.Context
//   - userID int
//   - refID reftag.IDt2
func (_e *MockServicer_Expecter) RemoveFavorite(ctx interface{}, userID interface{}, refID interface{}) *MockServicer_RemoveFavorite_Call {
	return &MockServicer_RemoveFavorite_Call{Call: _e.mock.On("RemoveFavorite", ctx, userID, refID)}
}

func (_c *MockServicer_RemoveFavorite_Call) Run(run func(ctx context.Context, userID int, refID reftag.IDt2)) *MockServicer_RemoveFavorite_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int), args[2].(reftag.IDt2))
	})
	return _c
}

func (_c *MockServicer_RemoveFavorite_Call) Return(_a0 errs.Error) *MockServicer_RemoveFavorite_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockServicer_RemoveFavorite_Call) RunAndReturn(run func(context.Context, int, reftag.IDt2) errs.Error) *MockServicer_RemoveFavorite_Call {
	_c.Call.Return(run)
	return _c
}

// SetUserVerified provides a mock function with given fields: ctx, user, verifier
func (_m *MockServicer) SetUserVerified(ctx context.Context, user *model.User, verifier *model.UserVerify) errs.Error {
	ret := _m.Called(ctx, user, verifier)

	if len(ret) == 0 {
		panic("no return value specified for SetUserVerified")
	}

	var r0 errs.Error
	if rf, ok := ret.Get(0).(func(context.Context, *model.User, *model.UserVerify) errs.Error); ok {
		r0 = rf(ctx, user, verifier)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(errs.Error)
		}
	}

	return r0
}

// MockServicer_SetUserVerified_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetUserVerified'
type MockServicer_SetUserVerified_Call struct {
	*mock.Call
}

// SetUserVerified is a helper method to define mock.On call
//   - ctx context.Context
//   - user *model.User
//   - verifier *model.UserVerify
func (_e *MockServicer_Expecter) SetUserVerified(ctx interface{}, user interface{}, verifier interface{}) *MockServicer_SetUserVerified_Call {
	return &MockServicer_SetUserVerified_Call{Call: _e.mock.On("SetUserVerified", ctx, user, verifier)}
}

func (_c *MockServicer_SetUserVerified_Call) Run(run func(ctx context.Context, user *model.User, verifier *model.UserVerify)) *MockServicer_SetUserVerified_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*model.User), args[2].(*model.UserVerify))
	})
	return _c
}

func (_c *MockServicer_SetUserVerified_Call) Return(_a0 errs.Error) *MockServicer_SetUserVerified_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockServicer_SetUserVerified_Call) RunAndReturn(run func(context.Context, *model.User, *model.UserVerify) errs.Error) *MockServicer_SetUserVerified_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateEvent provides a mock function with given fields: ctx, userID, refID, euvs
func (_m *MockServicer) UpdateEvent(ctx context.Context, userID int, refID reftag.IDt2, euvs *service.EventUpdateValues) errs.Error {
	ret := _m.Called(ctx, userID, refID, euvs)

	if len(ret) == 0 {
		panic("no return value specified for UpdateEvent")
	}

	var r0 errs.Error
	if rf, ok := ret.Get(0).(func(context.Context, int, reftag.IDt2, *service.EventUpdateValues) errs.Error); ok {
		r0 = rf(ctx, userID, refID, euvs)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(errs.Error)
		}
	}

	return r0
}

// MockServicer_UpdateEvent_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateEvent'
type MockServicer_UpdateEvent_Call struct {
	*mock.Call
}

// UpdateEvent is a helper method to define mock.On call
//   - ctx context.Context
//   - userID int
//   - refID reftag.IDt2
//   - euvs *service.EventUpdateValues
func (_e *MockServicer_Expecter) UpdateEvent(ctx interface{}, userID interface{}, refID interface{}, euvs interface{}) *MockServicer_UpdateEvent_Call {
	return &MockServicer_UpdateEvent_Call{Call: _e.mock.On("UpdateEvent", ctx, userID, refID, euvs)}
}

func (_c *MockServicer_UpdateEvent_Call) Run(run func(ctx context.Context, userID int, refID reftag.IDt2, euvs *service.EventUpdateValues)) *MockServicer_UpdateEvent_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int), args[2].(reftag.IDt2), args[3].(*service.EventUpdateValues))
	})
	return _c
}

func (_c *MockServicer_UpdateEvent_Call) Return(_a0 errs.Error) *MockServicer_UpdateEvent_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockServicer_UpdateEvent_Call) RunAndReturn(run func(context.Context, int, reftag.IDt2, *service.EventUpdateValues) errs.Error) *MockServicer_UpdateEvent_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateEventItem provides a mock function with given fields: ctx, userID, refID, description, failIfChecks
func (_m *MockServicer) UpdateEventItem(ctx context.Context, userID int, refID reftag.IDt3, description string, failIfChecks func(*model.EventItem) bool) (*model.EventItem, errs.Error) {
	ret := _m.Called(ctx, userID, refID, description, failIfChecks)

	if len(ret) == 0 {
		panic("no return value specified for UpdateEventItem")
	}

	var r0 *model.EventItem
	var r1 errs.Error
	if rf, ok := ret.Get(0).(func(context.Context, int, reftag.IDt3, string, func(*model.EventItem) bool) (*model.EventItem, errs.Error)); ok {
		return rf(ctx, userID, refID, description, failIfChecks)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int, reftag.IDt3, string, func(*model.EventItem) bool) *model.EventItem); ok {
		r0 = rf(ctx, userID, refID, description, failIfChecks)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.EventItem)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int, reftag.IDt3, string, func(*model.EventItem) bool) errs.Error); ok {
		r1 = rf(ctx, userID, refID, description, failIfChecks)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(errs.Error)
		}
	}

	return r0, r1
}

// MockServicer_UpdateEventItem_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateEventItem'
type MockServicer_UpdateEventItem_Call struct {
	*mock.Call
}

// UpdateEventItem is a helper method to define mock.On call
//   - ctx context.Context
//   - userID int
//   - refID reftag.IDt3
//   - description string
//   - failIfChecks func(*model.EventItem) bool
func (_e *MockServicer_Expecter) UpdateEventItem(ctx interface{}, userID interface{}, refID interface{}, description interface{}, failIfChecks interface{}) *MockServicer_UpdateEventItem_Call {
	return &MockServicer_UpdateEventItem_Call{Call: _e.mock.On("UpdateEventItem", ctx, userID, refID, description, failIfChecks)}
}

func (_c *MockServicer_UpdateEventItem_Call) Run(run func(ctx context.Context, userID int, refID reftag.IDt3, description string, failIfChecks func(*model.EventItem) bool)) *MockServicer_UpdateEventItem_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int), args[2].(reftag.IDt3), args[3].(string), args[4].(func(*model.EventItem) bool))
	})
	return _c
}

func (_c *MockServicer_UpdateEventItem_Call) Return(_a0 *model.EventItem, _a1 errs.Error) *MockServicer_UpdateEventItem_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockServicer_UpdateEventItem_Call) RunAndReturn(run func(context.Context, int, reftag.IDt3, string, func(*model.EventItem) bool) (*model.EventItem, errs.Error)) *MockServicer_UpdateEventItem_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateEventItemSorting provides a mock function with given fields: ctx, userID, refID, itemSortOrder
func (_m *MockServicer) UpdateEventItemSorting(ctx context.Context, userID int, refID reftag.IDt2, itemSortOrder []int) (*model.Event, errs.Error) {
	ret := _m.Called(ctx, userID, refID, itemSortOrder)

	if len(ret) == 0 {
		panic("no return value specified for UpdateEventItemSorting")
	}

	var r0 *model.Event
	var r1 errs.Error
	if rf, ok := ret.Get(0).(func(context.Context, int, reftag.IDt2, []int) (*model.Event, errs.Error)); ok {
		return rf(ctx, userID, refID, itemSortOrder)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int, reftag.IDt2, []int) *model.Event); ok {
		r0 = rf(ctx, userID, refID, itemSortOrder)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.Event)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int, reftag.IDt2, []int) errs.Error); ok {
		r1 = rf(ctx, userID, refID, itemSortOrder)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(errs.Error)
		}
	}

	return r0, r1
}

// MockServicer_UpdateEventItemSorting_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateEventItemSorting'
type MockServicer_UpdateEventItemSorting_Call struct {
	*mock.Call
}

// UpdateEventItemSorting is a helper method to define mock.On call
//   - ctx context.Context
//   - userID int
//   - refID reftag.IDt2
//   - itemSortOrder []int
func (_e *MockServicer_Expecter) UpdateEventItemSorting(ctx interface{}, userID interface{}, refID interface{}, itemSortOrder interface{}) *MockServicer_UpdateEventItemSorting_Call {
	return &MockServicer_UpdateEventItemSorting_Call{Call: _e.mock.On("UpdateEventItemSorting", ctx, userID, refID, itemSortOrder)}
}

func (_c *MockServicer_UpdateEventItemSorting_Call) Run(run func(ctx context.Context, userID int, refID reftag.IDt2, itemSortOrder []int)) *MockServicer_UpdateEventItemSorting_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int), args[2].(reftag.IDt2), args[3].([]int))
	})
	return _c
}

func (_c *MockServicer_UpdateEventItemSorting_Call) Return(_a0 *model.Event, _a1 errs.Error) *MockServicer_UpdateEventItemSorting_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockServicer_UpdateEventItemSorting_Call) RunAndReturn(run func(context.Context, int, reftag.IDt2, []int) (*model.Event, errs.Error)) *MockServicer_UpdateEventItemSorting_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateUser provides a mock function with given fields: ctx, userID, euvs
func (_m *MockServicer) UpdateUser(ctx context.Context, userID int, euvs *service.UserUpdateValues) errs.Error {
	ret := _m.Called(ctx, userID, euvs)

	if len(ret) == 0 {
		panic("no return value specified for UpdateUser")
	}

	var r0 errs.Error
	if rf, ok := ret.Get(0).(func(context.Context, int, *service.UserUpdateValues) errs.Error); ok {
		r0 = rf(ctx, userID, euvs)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(errs.Error)
		}
	}

	return r0
}

// MockServicer_UpdateUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateUser'
type MockServicer_UpdateUser_Call struct {
	*mock.Call
}

// UpdateUser is a helper method to define mock.On call
//   - ctx context.Context
//   - userID int
//   - euvs *service.UserUpdateValues
func (_e *MockServicer_Expecter) UpdateUser(ctx interface{}, userID interface{}, euvs interface{}) *MockServicer_UpdateUser_Call {
	return &MockServicer_UpdateUser_Call{Call: _e.mock.On("UpdateUser", ctx, userID, euvs)}
}

func (_c *MockServicer_UpdateUser_Call) Run(run func(ctx context.Context, userID int, euvs *service.UserUpdateValues)) *MockServicer_UpdateUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int), args[2].(*service.UserUpdateValues))
	})
	return _c
}

func (_c *MockServicer_UpdateUser_Call) Return(_a0 errs.Error) *MockServicer_UpdateUser_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockServicer_UpdateUser_Call) RunAndReturn(run func(context.Context, int, *service.UserUpdateValues) errs.Error) *MockServicer_UpdateUser_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateUserPWReset provides a mock function with given fields: ctx, user, upw
func (_m *MockServicer) UpdateUserPWReset(ctx context.Context, user *model.User, upw *model.UserPWReset) errs.Error {
	ret := _m.Called(ctx, user, upw)

	if len(ret) == 0 {
		panic("no return value specified for UpdateUserPWReset")
	}

	var r0 errs.Error
	if rf, ok := ret.Get(0).(func(context.Context, *model.User, *model.UserPWReset) errs.Error); ok {
		r0 = rf(ctx, user, upw)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(errs.Error)
		}
	}

	return r0
}

// MockServicer_UpdateUserPWReset_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateUserPWReset'
type MockServicer_UpdateUserPWReset_Call struct {
	*mock.Call
}

// UpdateUserPWReset is a helper method to define mock.On call
//   - ctx context.Context
//   - user *model.User
//   - upw *model.UserPWReset
func (_e *MockServicer_Expecter) UpdateUserPWReset(ctx interface{}, user interface{}, upw interface{}) *MockServicer_UpdateUserPWReset_Call {
	return &MockServicer_UpdateUserPWReset_Call{Call: _e.mock.On("UpdateUserPWReset", ctx, user, upw)}
}

func (_c *MockServicer_UpdateUserPWReset_Call) Run(run func(ctx context.Context, user *model.User, upw *model.UserPWReset)) *MockServicer_UpdateUserPWReset_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*model.User), args[2].(*model.UserPWReset))
	})
	return _c
}

func (_c *MockServicer_UpdateUserPWReset_Call) Return(_a0 errs.Error) *MockServicer_UpdateUserPWReset_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockServicer_UpdateUserPWReset_Call) RunAndReturn(run func(context.Context, *model.User, *model.UserPWReset) errs.Error) *MockServicer_UpdateUserPWReset_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateUserSettings provides a mock function with given fields: ctx, userID, pm
func (_m *MockServicer) UpdateUserSettings(ctx context.Context, userID int, pm *model.UserSettings) errs.Error {
	ret := _m.Called(ctx, userID, pm)

	if len(ret) == 0 {
		panic("no return value specified for UpdateUserSettings")
	}

	var r0 errs.Error
	if rf, ok := ret.Get(0).(func(context.Context, int, *model.UserSettings) errs.Error); ok {
		r0 = rf(ctx, userID, pm)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(errs.Error)
		}
	}

	return r0
}

// MockServicer_UpdateUserSettings_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateUserSettings'
type MockServicer_UpdateUserSettings_Call struct {
	*mock.Call
}

// UpdateUserSettings is a helper method to define mock.On call
//   - ctx context.Context
//   - userID int
//   - pm *model.UserSettings
func (_e *MockServicer_Expecter) UpdateUserSettings(ctx interface{}, userID interface{}, pm interface{}) *MockServicer_UpdateUserSettings_Call {
	return &MockServicer_UpdateUserSettings_Call{Call: _e.mock.On("UpdateUserSettings", ctx, userID, pm)}
}

func (_c *MockServicer_UpdateUserSettings_Call) Run(run func(ctx context.Context, userID int, pm *model.UserSettings)) *MockServicer_UpdateUserSettings_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int), args[2].(*model.UserSettings))
	})
	return _c
}

func (_c *MockServicer_UpdateUserSettings_Call) Return(_a0 errs.Error) *MockServicer_UpdateUserSettings_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockServicer_UpdateUserSettings_Call) RunAndReturn(run func(context.Context, int, *model.UserSettings) errs.Error) *MockServicer_UpdateUserSettings_Call {
	_c.Call.Return(run)
	return _c
}

// WebAuthnUserFrom provides a mock function with given fields: user
func (_m *MockServicer) WebAuthnUserFrom(user *model.User) *service.WebAuthnUser {
	ret := _m.Called(user)

	if len(ret) == 0 {
		panic("no return value specified for WebAuthnUserFrom")
	}

	var r0 *service.WebAuthnUser
	if rf, ok := ret.Get(0).(func(*model.User) *service.WebAuthnUser); ok {
		r0 = rf(user)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*service.WebAuthnUser)
		}
	}

	return r0
}

// MockServicer_WebAuthnUserFrom_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WebAuthnUserFrom'
type MockServicer_WebAuthnUserFrom_Call struct {
	*mock.Call
}

// WebAuthnUserFrom is a helper method to define mock.On call
//   - user *model.User
func (_e *MockServicer_Expecter) WebAuthnUserFrom(user interface{}) *MockServicer_WebAuthnUserFrom_Call {
	return &MockServicer_WebAuthnUserFrom_Call{Call: _e.mock.On("WebAuthnUserFrom", user)}
}

func (_c *MockServicer_WebAuthnUserFrom_Call) Run(run func(user *model.User)) *MockServicer_WebAuthnUserFrom_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*model.User))
	})
	return _c
}

func (_c *MockServicer_WebAuthnUserFrom_Call) Return(_a0 *service.WebAuthnUser) *MockServicer_WebAuthnUserFrom_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockServicer_WebAuthnUserFrom_Call) RunAndReturn(run func(*model.User) *service.WebAuthnUser) *MockServicer_WebAuthnUserFrom_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockServicer creates a new instance of MockServicer. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockServicer(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockServicer {
	mock := &MockServicer{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
